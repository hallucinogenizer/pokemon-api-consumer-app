/**
 * Generated by orval v7.8.0 🍺
 * Do not edit manually.
 * PokéAPI
 * All the Pokémon data you'll ever need in one place, easily accessible through a modern free open-source RESTful API.

## What is this?

This is a full RESTful API linked to an extensive database detailing everything about the Pokémon main game series.

We've covered everything from Pokémon to Berry Flavors.

## Where do I start?

We have awesome [documentation](https://pokeapi.co/docs/v2) on how to use this API. It takes minutes to get started.

This API will always be publicly available and will never require any extensive setup process to consume.

Created by [**Paul Hallett**](https://github.com/phalt) and other [**PokéAPI contributors***](https://github.com/PokeAPI/pokeapi#contributing) around the world. Pokémon and Pokémon character names are trademarks of Nintendo.
    
 * OpenAPI spec version: 2.7.0
 */
import {
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  EncounterConditionDetail,
  EncounterConditionListParams,
  EncounterConditionValueDetail,
  EncounterConditionValueListParams,
  EncounterMethodDetail,
  EncounterMethodListParams,
  PaginatedEncounterConditionSummaryList,
  PaginatedEncounterConditionValueSummaryList,
  PaginatedEncounterMethodSummaryList,
  PokemonEncountersRetrieve200Item
} from '.././model';





/**
 * Methods by which the player might can encounter Pokémon in the wild, e.g., walking in tall grass. Check out Bulbapedia for greater detail.
 * @summary List encounter methods
 */
export type encounterMethodListResponse200 = {
  data: PaginatedEncounterMethodSummaryList
  status: 200
}
    
export type encounterMethodListResponseComposite = encounterMethodListResponse200;
    
export type encounterMethodListResponse = encounterMethodListResponseComposite & {
  headers: Headers;
}

export const getEncounterMethodListUrl = (params?: EncounterMethodListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/encounter-method/?${stringifiedParams}` : `https://pokeapi.co/api/v2/encounter-method/`
}

export const encounterMethodList = async (params?: EncounterMethodListParams, options?: RequestInit): Promise<encounterMethodListResponse> => {
  
  const res = await fetch(getEncounterMethodListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: encounterMethodListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as encounterMethodListResponse
}



export const getEncounterMethodListQueryKey = (params?: EncounterMethodListParams,) => {
    return [`https://pokeapi.co/api/v2/encounter-method/`, ...(params ? [params]: [])] as const;
    }

    
export const getEncounterMethodListQueryOptions = <TData = Awaited<ReturnType<typeof encounterMethodList>>, TError = unknown>(params?: EncounterMethodListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterMethodList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEncounterMethodListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof encounterMethodList>>> = ({ signal }) => encounterMethodList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof encounterMethodList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EncounterMethodListQueryResult = NonNullable<Awaited<ReturnType<typeof encounterMethodList>>>
export type EncounterMethodListQueryError = unknown


export function useEncounterMethodList<TData = Awaited<ReturnType<typeof encounterMethodList>>, TError = unknown>(
 params: undefined |  EncounterMethodListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterMethodList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterMethodList>>,
          TError,
          Awaited<ReturnType<typeof encounterMethodList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEncounterMethodList<TData = Awaited<ReturnType<typeof encounterMethodList>>, TError = unknown>(
 params?: EncounterMethodListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterMethodList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterMethodList>>,
          TError,
          Awaited<ReturnType<typeof encounterMethodList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEncounterMethodList<TData = Awaited<ReturnType<typeof encounterMethodList>>, TError = unknown>(
 params?: EncounterMethodListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterMethodList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List encounter methods
 */

export function useEncounterMethodList<TData = Awaited<ReturnType<typeof encounterMethodList>>, TError = unknown>(
 params?: EncounterMethodListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterMethodList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEncounterMethodListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Methods by which the player might can encounter Pokémon in the wild, e.g., walking in tall grass. Check out Bulbapedia for greater detail.
 * @summary Get encounter method
 */
export type encounterMethodRetrieveResponse200 = {
  data: EncounterMethodDetail
  status: 200
}
    
export type encounterMethodRetrieveResponseComposite = encounterMethodRetrieveResponse200;
    
export type encounterMethodRetrieveResponse = encounterMethodRetrieveResponseComposite & {
  headers: Headers;
}

export const getEncounterMethodRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/encounter-method/${id}/`
}

export const encounterMethodRetrieve = async (id: string, options?: RequestInit): Promise<encounterMethodRetrieveResponse> => {
  
  const res = await fetch(getEncounterMethodRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: encounterMethodRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as encounterMethodRetrieveResponse
}



export const getEncounterMethodRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/encounter-method/${id}/`] as const;
    }

    
export const getEncounterMethodRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof encounterMethodRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterMethodRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEncounterMethodRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof encounterMethodRetrieve>>> = ({ signal }) => encounterMethodRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof encounterMethodRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EncounterMethodRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof encounterMethodRetrieve>>>
export type EncounterMethodRetrieveQueryError = unknown


export function useEncounterMethodRetrieve<TData = Awaited<ReturnType<typeof encounterMethodRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterMethodRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterMethodRetrieve>>,
          TError,
          Awaited<ReturnType<typeof encounterMethodRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEncounterMethodRetrieve<TData = Awaited<ReturnType<typeof encounterMethodRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterMethodRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterMethodRetrieve>>,
          TError,
          Awaited<ReturnType<typeof encounterMethodRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEncounterMethodRetrieve<TData = Awaited<ReturnType<typeof encounterMethodRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterMethodRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get encounter method
 */

export function useEncounterMethodRetrieve<TData = Awaited<ReturnType<typeof encounterMethodRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterMethodRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEncounterMethodRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Conditions which affect what pokemon might appear in the wild, e.g., day or night.
 * @summary List encounter conditions
 */
export type encounterConditionListResponse200 = {
  data: PaginatedEncounterConditionSummaryList
  status: 200
}
    
export type encounterConditionListResponseComposite = encounterConditionListResponse200;
    
export type encounterConditionListResponse = encounterConditionListResponseComposite & {
  headers: Headers;
}

export const getEncounterConditionListUrl = (params?: EncounterConditionListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/encounter-condition/?${stringifiedParams}` : `https://pokeapi.co/api/v2/encounter-condition/`
}

export const encounterConditionList = async (params?: EncounterConditionListParams, options?: RequestInit): Promise<encounterConditionListResponse> => {
  
  const res = await fetch(getEncounterConditionListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: encounterConditionListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as encounterConditionListResponse
}



export const getEncounterConditionListQueryKey = (params?: EncounterConditionListParams,) => {
    return [`https://pokeapi.co/api/v2/encounter-condition/`, ...(params ? [params]: [])] as const;
    }

    
export const getEncounterConditionListQueryOptions = <TData = Awaited<ReturnType<typeof encounterConditionList>>, TError = unknown>(params?: EncounterConditionListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterConditionList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEncounterConditionListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof encounterConditionList>>> = ({ signal }) => encounterConditionList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof encounterConditionList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EncounterConditionListQueryResult = NonNullable<Awaited<ReturnType<typeof encounterConditionList>>>
export type EncounterConditionListQueryError = unknown


export function useEncounterConditionList<TData = Awaited<ReturnType<typeof encounterConditionList>>, TError = unknown>(
 params: undefined |  EncounterConditionListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterConditionList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterConditionList>>,
          TError,
          Awaited<ReturnType<typeof encounterConditionList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEncounterConditionList<TData = Awaited<ReturnType<typeof encounterConditionList>>, TError = unknown>(
 params?: EncounterConditionListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterConditionList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterConditionList>>,
          TError,
          Awaited<ReturnType<typeof encounterConditionList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEncounterConditionList<TData = Awaited<ReturnType<typeof encounterConditionList>>, TError = unknown>(
 params?: EncounterConditionListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterConditionList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List encounter conditions
 */

export function useEncounterConditionList<TData = Awaited<ReturnType<typeof encounterConditionList>>, TError = unknown>(
 params?: EncounterConditionListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterConditionList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEncounterConditionListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Conditions which affect what pokemon might appear in the wild, e.g., day or night.
 * @summary Get encounter condition
 */
export type encounterConditionRetrieveResponse200 = {
  data: EncounterConditionDetail
  status: 200
}
    
export type encounterConditionRetrieveResponseComposite = encounterConditionRetrieveResponse200;
    
export type encounterConditionRetrieveResponse = encounterConditionRetrieveResponseComposite & {
  headers: Headers;
}

export const getEncounterConditionRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/encounter-condition/${id}/`
}

export const encounterConditionRetrieve = async (id: string, options?: RequestInit): Promise<encounterConditionRetrieveResponse> => {
  
  const res = await fetch(getEncounterConditionRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: encounterConditionRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as encounterConditionRetrieveResponse
}



export const getEncounterConditionRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/encounter-condition/${id}/`] as const;
    }

    
export const getEncounterConditionRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof encounterConditionRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterConditionRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEncounterConditionRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof encounterConditionRetrieve>>> = ({ signal }) => encounterConditionRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof encounterConditionRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EncounterConditionRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof encounterConditionRetrieve>>>
export type EncounterConditionRetrieveQueryError = unknown


export function useEncounterConditionRetrieve<TData = Awaited<ReturnType<typeof encounterConditionRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterConditionRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterConditionRetrieve>>,
          TError,
          Awaited<ReturnType<typeof encounterConditionRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEncounterConditionRetrieve<TData = Awaited<ReturnType<typeof encounterConditionRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterConditionRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterConditionRetrieve>>,
          TError,
          Awaited<ReturnType<typeof encounterConditionRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEncounterConditionRetrieve<TData = Awaited<ReturnType<typeof encounterConditionRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterConditionRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get encounter condition
 */

export function useEncounterConditionRetrieve<TData = Awaited<ReturnType<typeof encounterConditionRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterConditionRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEncounterConditionRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Encounter condition values are the various states that an encounter condition can have, i.e., time of day can be either day or night.
 * @summary List encounter condition values
 */
export type encounterConditionValueListResponse200 = {
  data: PaginatedEncounterConditionValueSummaryList
  status: 200
}
    
export type encounterConditionValueListResponseComposite = encounterConditionValueListResponse200;
    
export type encounterConditionValueListResponse = encounterConditionValueListResponseComposite & {
  headers: Headers;
}

export const getEncounterConditionValueListUrl = (params?: EncounterConditionValueListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/encounter-condition-value/?${stringifiedParams}` : `https://pokeapi.co/api/v2/encounter-condition-value/`
}

export const encounterConditionValueList = async (params?: EncounterConditionValueListParams, options?: RequestInit): Promise<encounterConditionValueListResponse> => {
  
  const res = await fetch(getEncounterConditionValueListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: encounterConditionValueListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as encounterConditionValueListResponse
}



export const getEncounterConditionValueListQueryKey = (params?: EncounterConditionValueListParams,) => {
    return [`https://pokeapi.co/api/v2/encounter-condition-value/`, ...(params ? [params]: [])] as const;
    }

    
export const getEncounterConditionValueListQueryOptions = <TData = Awaited<ReturnType<typeof encounterConditionValueList>>, TError = unknown>(params?: EncounterConditionValueListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterConditionValueList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEncounterConditionValueListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof encounterConditionValueList>>> = ({ signal }) => encounterConditionValueList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof encounterConditionValueList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EncounterConditionValueListQueryResult = NonNullable<Awaited<ReturnType<typeof encounterConditionValueList>>>
export type EncounterConditionValueListQueryError = unknown


export function useEncounterConditionValueList<TData = Awaited<ReturnType<typeof encounterConditionValueList>>, TError = unknown>(
 params: undefined |  EncounterConditionValueListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterConditionValueList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterConditionValueList>>,
          TError,
          Awaited<ReturnType<typeof encounterConditionValueList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEncounterConditionValueList<TData = Awaited<ReturnType<typeof encounterConditionValueList>>, TError = unknown>(
 params?: EncounterConditionValueListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterConditionValueList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterConditionValueList>>,
          TError,
          Awaited<ReturnType<typeof encounterConditionValueList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEncounterConditionValueList<TData = Awaited<ReturnType<typeof encounterConditionValueList>>, TError = unknown>(
 params?: EncounterConditionValueListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterConditionValueList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List encounter condition values
 */

export function useEncounterConditionValueList<TData = Awaited<ReturnType<typeof encounterConditionValueList>>, TError = unknown>(
 params?: EncounterConditionValueListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterConditionValueList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEncounterConditionValueListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Encounter condition values are the various states that an encounter condition can have, i.e., time of day can be either day or night.
 * @summary Get encounter condition value
 */
export type encounterConditionValueRetrieveResponse200 = {
  data: EncounterConditionValueDetail
  status: 200
}
    
export type encounterConditionValueRetrieveResponseComposite = encounterConditionValueRetrieveResponse200;
    
export type encounterConditionValueRetrieveResponse = encounterConditionValueRetrieveResponseComposite & {
  headers: Headers;
}

export const getEncounterConditionValueRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/encounter-condition-value/${id}/`
}

export const encounterConditionValueRetrieve = async (id: string, options?: RequestInit): Promise<encounterConditionValueRetrieveResponse> => {
  
  const res = await fetch(getEncounterConditionValueRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: encounterConditionValueRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as encounterConditionValueRetrieveResponse
}



export const getEncounterConditionValueRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/encounter-condition-value/${id}/`] as const;
    }

    
export const getEncounterConditionValueRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof encounterConditionValueRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterConditionValueRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEncounterConditionValueRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof encounterConditionValueRetrieve>>> = ({ signal }) => encounterConditionValueRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof encounterConditionValueRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EncounterConditionValueRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof encounterConditionValueRetrieve>>>
export type EncounterConditionValueRetrieveQueryError = unknown


export function useEncounterConditionValueRetrieve<TData = Awaited<ReturnType<typeof encounterConditionValueRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterConditionValueRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterConditionValueRetrieve>>,
          TError,
          Awaited<ReturnType<typeof encounterConditionValueRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEncounterConditionValueRetrieve<TData = Awaited<ReturnType<typeof encounterConditionValueRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterConditionValueRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterConditionValueRetrieve>>,
          TError,
          Awaited<ReturnType<typeof encounterConditionValueRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEncounterConditionValueRetrieve<TData = Awaited<ReturnType<typeof encounterConditionValueRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterConditionValueRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get encounter condition value
 */

export function useEncounterConditionValueRetrieve<TData = Awaited<ReturnType<typeof encounterConditionValueRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof encounterConditionValueRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEncounterConditionValueRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Handles Pokemon Encounters as a sub-resource.
 * @summary Get pokemon encounter
 */
export type pokemonEncountersRetrieveResponse200 = {
  data: PokemonEncountersRetrieve200Item[]
  status: 200
}
    
export type pokemonEncountersRetrieveResponseComposite = pokemonEncountersRetrieveResponse200;
    
export type pokemonEncountersRetrieveResponse = pokemonEncountersRetrieveResponseComposite & {
  headers: Headers;
}

export const getPokemonEncountersRetrieveUrl = (pokemonId: string,) => {


  

  return `https://pokeapi.co/api/v2/pokemon/${pokemonId}/encounters`
}

export const pokemonEncountersRetrieve = async (pokemonId: string, options?: RequestInit): Promise<pokemonEncountersRetrieveResponse> => {
  
  const res = await fetch(getPokemonEncountersRetrieveUrl(pokemonId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: pokemonEncountersRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as pokemonEncountersRetrieveResponse
}



export const getPokemonEncountersRetrieveQueryKey = (pokemonId: string,) => {
    return [`https://pokeapi.co/api/v2/pokemon/${pokemonId}/encounters`] as const;
    }

    
export const getPokemonEncountersRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof pokemonEncountersRetrieve>>, TError = unknown>(pokemonId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonEncountersRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPokemonEncountersRetrieveQueryKey(pokemonId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pokemonEncountersRetrieve>>> = ({ signal }) => pokemonEncountersRetrieve(pokemonId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(pokemonId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pokemonEncountersRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PokemonEncountersRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof pokemonEncountersRetrieve>>>
export type PokemonEncountersRetrieveQueryError = unknown


export function usePokemonEncountersRetrieve<TData = Awaited<ReturnType<typeof pokemonEncountersRetrieve>>, TError = unknown>(
 pokemonId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonEncountersRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonEncountersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonEncountersRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokemonEncountersRetrieve<TData = Awaited<ReturnType<typeof pokemonEncountersRetrieve>>, TError = unknown>(
 pokemonId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonEncountersRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonEncountersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonEncountersRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokemonEncountersRetrieve<TData = Awaited<ReturnType<typeof pokemonEncountersRetrieve>>, TError = unknown>(
 pokemonId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonEncountersRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get pokemon encounter
 */

export function usePokemonEncountersRetrieve<TData = Awaited<ReturnType<typeof pokemonEncountersRetrieve>>, TError = unknown>(
 pokemonId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonEncountersRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPokemonEncountersRetrieveQueryOptions(pokemonId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



