/**
 * Generated by orval v7.8.0 ðŸº
 * Do not edit manually.
 * PokÃ©API
 * All the PokÃ©mon data you'll ever need in one place, easily accessible through a modern free open-source RESTful API.

## What is this?

This is a full RESTful API linked to an extensive database detailing everything about the PokÃ©mon main game series.

We've covered everything from PokÃ©mon to Berry Flavors.

## Where do I start?

We have awesome [documentation](https://pokeapi.co/docs/v2) on how to use this API. It takes minutes to get started.

This API will always be publicly available and will never require any extensive setup process to consume.

Created by [**Paul Hallett**](https://github.com/phalt) and other [**PokÃ©API contributors***](https://github.com/PokeAPI/pokeapi#contributing) around the world. PokÃ©mon and PokÃ©mon character names are trademarks of Nintendo.
    
 * OpenAPI spec version: 2.7.0
 */
import {
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  BerryDetail,
  BerryFirmnessDetail,
  BerryFirmnessListParams,
  BerryFlavorDetail,
  BerryFlavorListParams,
  BerryListParams,
  PaginatedBerryFirmnessSummaryList,
  PaginatedBerryFlavorSummaryList,
  PaginatedBerrySummaryList
} from '.././model';





/**
 * Berries are small fruits that can provide HP and status condition restoration, stat enhancement, and even damage negation when eaten by PokÃ©mon. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Berry) for greater detail.
 * @summary List berries
 */
export type berryListResponse200 = {
  data: PaginatedBerrySummaryList
  status: 200
}
    
export type berryListResponseComposite = berryListResponse200;
    
export type berryListResponse = berryListResponseComposite & {
  headers: Headers;
}

export const getBerryListUrl = (params?: BerryListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/berry/?${stringifiedParams}` : `https://pokeapi.co/api/v2/berry/`
}

export const berryList = async (params?: BerryListParams, options?: RequestInit): Promise<berryListResponse> => {
  
  const res = await fetch(getBerryListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: berryListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as berryListResponse
}



export const getBerryListQueryKey = (params?: BerryListParams,) => {
    return [`https://pokeapi.co/api/v2/berry/`, ...(params ? [params]: [])] as const;
    }

    
export const getBerryListQueryOptions = <TData = Awaited<ReturnType<typeof berryList>>, TError = unknown>(params?: BerryListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBerryListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof berryList>>> = ({ signal }) => berryList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof berryList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BerryListQueryResult = NonNullable<Awaited<ReturnType<typeof berryList>>>
export type BerryListQueryError = unknown


export function useBerryList<TData = Awaited<ReturnType<typeof berryList>>, TError = unknown>(
 params: undefined |  BerryListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryList>>,
          TError,
          Awaited<ReturnType<typeof berryList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBerryList<TData = Awaited<ReturnType<typeof berryList>>, TError = unknown>(
 params?: BerryListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryList>>,
          TError,
          Awaited<ReturnType<typeof berryList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBerryList<TData = Awaited<ReturnType<typeof berryList>>, TError = unknown>(
 params?: BerryListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List berries
 */

export function useBerryList<TData = Awaited<ReturnType<typeof berryList>>, TError = unknown>(
 params?: BerryListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBerryListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Berries are small fruits that can provide HP and status condition restoration, stat enhancement, and even damage negation when eaten by PokÃ©mon. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Berry) for greater detail.
 * @summary Get a berry
 */
export type berryRetrieveResponse200 = {
  data: BerryDetail
  status: 200
}
    
export type berryRetrieveResponseComposite = berryRetrieveResponse200;
    
export type berryRetrieveResponse = berryRetrieveResponseComposite & {
  headers: Headers;
}

export const getBerryRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/berry/${id}/`
}

export const berryRetrieve = async (id: string, options?: RequestInit): Promise<berryRetrieveResponse> => {
  
  const res = await fetch(getBerryRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: berryRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as berryRetrieveResponse
}



export const getBerryRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/berry/${id}/`] as const;
    }

    
export const getBerryRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof berryRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBerryRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof berryRetrieve>>> = ({ signal }) => berryRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof berryRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BerryRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof berryRetrieve>>>
export type BerryRetrieveQueryError = unknown


export function useBerryRetrieve<TData = Awaited<ReturnType<typeof berryRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryRetrieve>>,
          TError,
          Awaited<ReturnType<typeof berryRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBerryRetrieve<TData = Awaited<ReturnType<typeof berryRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryRetrieve>>,
          TError,
          Awaited<ReturnType<typeof berryRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBerryRetrieve<TData = Awaited<ReturnType<typeof berryRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a berry
 */

export function useBerryRetrieve<TData = Awaited<ReturnType<typeof berryRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBerryRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Berries can be soft or hard. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Category:Berries_by_firmness) for greater detail.
 * @summary List berry firmness
 */
export type berryFirmnessListResponse200 = {
  data: PaginatedBerryFirmnessSummaryList
  status: 200
}
    
export type berryFirmnessListResponseComposite = berryFirmnessListResponse200;
    
export type berryFirmnessListResponse = berryFirmnessListResponseComposite & {
  headers: Headers;
}

export const getBerryFirmnessListUrl = (params?: BerryFirmnessListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/berry-firmness/?${stringifiedParams}` : `https://pokeapi.co/api/v2/berry-firmness/`
}

export const berryFirmnessList = async (params?: BerryFirmnessListParams, options?: RequestInit): Promise<berryFirmnessListResponse> => {
  
  const res = await fetch(getBerryFirmnessListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: berryFirmnessListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as berryFirmnessListResponse
}



export const getBerryFirmnessListQueryKey = (params?: BerryFirmnessListParams,) => {
    return [`https://pokeapi.co/api/v2/berry-firmness/`, ...(params ? [params]: [])] as const;
    }

    
export const getBerryFirmnessListQueryOptions = <TData = Awaited<ReturnType<typeof berryFirmnessList>>, TError = unknown>(params?: BerryFirmnessListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryFirmnessList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBerryFirmnessListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof berryFirmnessList>>> = ({ signal }) => berryFirmnessList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof berryFirmnessList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BerryFirmnessListQueryResult = NonNullable<Awaited<ReturnType<typeof berryFirmnessList>>>
export type BerryFirmnessListQueryError = unknown


export function useBerryFirmnessList<TData = Awaited<ReturnType<typeof berryFirmnessList>>, TError = unknown>(
 params: undefined |  BerryFirmnessListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryFirmnessList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryFirmnessList>>,
          TError,
          Awaited<ReturnType<typeof berryFirmnessList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBerryFirmnessList<TData = Awaited<ReturnType<typeof berryFirmnessList>>, TError = unknown>(
 params?: BerryFirmnessListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryFirmnessList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryFirmnessList>>,
          TError,
          Awaited<ReturnType<typeof berryFirmnessList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBerryFirmnessList<TData = Awaited<ReturnType<typeof berryFirmnessList>>, TError = unknown>(
 params?: BerryFirmnessListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryFirmnessList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List berry firmness
 */

export function useBerryFirmnessList<TData = Awaited<ReturnType<typeof berryFirmnessList>>, TError = unknown>(
 params?: BerryFirmnessListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryFirmnessList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBerryFirmnessListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Berries can be soft or hard. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Category:Berries_by_firmness) for greater detail.
 * @summary Get berry by firmness
 */
export type berryFirmnessRetrieveResponse200 = {
  data: BerryFirmnessDetail
  status: 200
}
    
export type berryFirmnessRetrieveResponseComposite = berryFirmnessRetrieveResponse200;
    
export type berryFirmnessRetrieveResponse = berryFirmnessRetrieveResponseComposite & {
  headers: Headers;
}

export const getBerryFirmnessRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/berry-firmness/${id}/`
}

export const berryFirmnessRetrieve = async (id: string, options?: RequestInit): Promise<berryFirmnessRetrieveResponse> => {
  
  const res = await fetch(getBerryFirmnessRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: berryFirmnessRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as berryFirmnessRetrieveResponse
}



export const getBerryFirmnessRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/berry-firmness/${id}/`] as const;
    }

    
export const getBerryFirmnessRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof berryFirmnessRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryFirmnessRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBerryFirmnessRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof berryFirmnessRetrieve>>> = ({ signal }) => berryFirmnessRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof berryFirmnessRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BerryFirmnessRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof berryFirmnessRetrieve>>>
export type BerryFirmnessRetrieveQueryError = unknown


export function useBerryFirmnessRetrieve<TData = Awaited<ReturnType<typeof berryFirmnessRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryFirmnessRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryFirmnessRetrieve>>,
          TError,
          Awaited<ReturnType<typeof berryFirmnessRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBerryFirmnessRetrieve<TData = Awaited<ReturnType<typeof berryFirmnessRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryFirmnessRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryFirmnessRetrieve>>,
          TError,
          Awaited<ReturnType<typeof berryFirmnessRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBerryFirmnessRetrieve<TData = Awaited<ReturnType<typeof berryFirmnessRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryFirmnessRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get berry by firmness
 */

export function useBerryFirmnessRetrieve<TData = Awaited<ReturnType<typeof berryFirmnessRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryFirmnessRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBerryFirmnessRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Flavors determine whether a PokÃ©mon will benefit or suffer from eating a berry based on their **nature**. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Flavor) for greater detail.
 * @summary List berry flavors
 */
export type berryFlavorListResponse200 = {
  data: PaginatedBerryFlavorSummaryList
  status: 200
}
    
export type berryFlavorListResponseComposite = berryFlavorListResponse200;
    
export type berryFlavorListResponse = berryFlavorListResponseComposite & {
  headers: Headers;
}

export const getBerryFlavorListUrl = (params?: BerryFlavorListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/berry-flavor/?${stringifiedParams}` : `https://pokeapi.co/api/v2/berry-flavor/`
}

export const berryFlavorList = async (params?: BerryFlavorListParams, options?: RequestInit): Promise<berryFlavorListResponse> => {
  
  const res = await fetch(getBerryFlavorListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: berryFlavorListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as berryFlavorListResponse
}



export const getBerryFlavorListQueryKey = (params?: BerryFlavorListParams,) => {
    return [`https://pokeapi.co/api/v2/berry-flavor/`, ...(params ? [params]: [])] as const;
    }

    
export const getBerryFlavorListQueryOptions = <TData = Awaited<ReturnType<typeof berryFlavorList>>, TError = unknown>(params?: BerryFlavorListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryFlavorList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBerryFlavorListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof berryFlavorList>>> = ({ signal }) => berryFlavorList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof berryFlavorList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BerryFlavorListQueryResult = NonNullable<Awaited<ReturnType<typeof berryFlavorList>>>
export type BerryFlavorListQueryError = unknown


export function useBerryFlavorList<TData = Awaited<ReturnType<typeof berryFlavorList>>, TError = unknown>(
 params: undefined |  BerryFlavorListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryFlavorList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryFlavorList>>,
          TError,
          Awaited<ReturnType<typeof berryFlavorList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBerryFlavorList<TData = Awaited<ReturnType<typeof berryFlavorList>>, TError = unknown>(
 params?: BerryFlavorListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryFlavorList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryFlavorList>>,
          TError,
          Awaited<ReturnType<typeof berryFlavorList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBerryFlavorList<TData = Awaited<ReturnType<typeof berryFlavorList>>, TError = unknown>(
 params?: BerryFlavorListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryFlavorList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List berry flavors
 */

export function useBerryFlavorList<TData = Awaited<ReturnType<typeof berryFlavorList>>, TError = unknown>(
 params?: BerryFlavorListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryFlavorList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBerryFlavorListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Flavors determine whether a PokÃ©mon will benefit or suffer from eating a berry based on their **nature**. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Flavor) for greater detail.
 * @summary Get berries by flavor
 */
export type berryFlavorRetrieveResponse200 = {
  data: BerryFlavorDetail
  status: 200
}
    
export type berryFlavorRetrieveResponseComposite = berryFlavorRetrieveResponse200;
    
export type berryFlavorRetrieveResponse = berryFlavorRetrieveResponseComposite & {
  headers: Headers;
}

export const getBerryFlavorRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/berry-flavor/${id}/`
}

export const berryFlavorRetrieve = async (id: string, options?: RequestInit): Promise<berryFlavorRetrieveResponse> => {
  
  const res = await fetch(getBerryFlavorRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: berryFlavorRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as berryFlavorRetrieveResponse
}



export const getBerryFlavorRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/berry-flavor/${id}/`] as const;
    }

    
export const getBerryFlavorRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof berryFlavorRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryFlavorRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBerryFlavorRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof berryFlavorRetrieve>>> = ({ signal }) => berryFlavorRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof berryFlavorRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BerryFlavorRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof berryFlavorRetrieve>>>
export type BerryFlavorRetrieveQueryError = unknown


export function useBerryFlavorRetrieve<TData = Awaited<ReturnType<typeof berryFlavorRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryFlavorRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryFlavorRetrieve>>,
          TError,
          Awaited<ReturnType<typeof berryFlavorRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBerryFlavorRetrieve<TData = Awaited<ReturnType<typeof berryFlavorRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryFlavorRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryFlavorRetrieve>>,
          TError,
          Awaited<ReturnType<typeof berryFlavorRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBerryFlavorRetrieve<TData = Awaited<ReturnType<typeof berryFlavorRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryFlavorRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get berries by flavor
 */

export function useBerryFlavorRetrieve<TData = Awaited<ReturnType<typeof berryFlavorRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof berryFlavorRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBerryFlavorRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



