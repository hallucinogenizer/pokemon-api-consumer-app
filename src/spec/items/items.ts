/**
 * Generated by orval v7.8.0 ðŸº
 * Do not edit manually.
 * PokÃ©API
 * All the PokÃ©mon data you'll ever need in one place, easily accessible through a modern free open-source RESTful API.

## What is this?

This is a full RESTful API linked to an extensive database detailing everything about the PokÃ©mon main game series.

We've covered everything from PokÃ©mon to Berry Flavors.

## Where do I start?

We have awesome [documentation](https://pokeapi.co/docs/v2) on how to use this API. It takes minutes to get started.

This API will always be publicly available and will never require any extensive setup process to consume.

Created by [**Paul Hallett**](https://github.com/phalt) and other [**PokÃ©API contributors***](https://github.com/PokeAPI/pokeapi#contributing) around the world. PokÃ©mon and PokÃ©mon character names are trademarks of Nintendo.
    
 * OpenAPI spec version: 2.7.0
 */
import {
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  ItemAttributeDetail,
  ItemAttributeListParams,
  ItemCategoryDetail,
  ItemCategoryListParams,
  ItemDetail,
  ItemFlingEffectDetail,
  ItemFlingEffectListParams,
  ItemListParams,
  ItemPocketDetail,
  ItemPocketListParams,
  PaginatedItemAttributeSummaryList,
  PaginatedItemCategorySummaryList,
  PaginatedItemFlingEffectSummaryList,
  PaginatedItemPocketSummaryList,
  PaginatedItemSummaryList
} from '.././model';





/**
 * An item is an object in the games which the player can pick up, keep in their bag, and use in some manner. They have various uses, including healing, powering up, helping catch PokÃ©mon, or to access a new area.
 * @summary List items
 */
export type itemListResponse200 = {
  data: PaginatedItemSummaryList
  status: 200
}
    
export type itemListResponseComposite = itemListResponse200;
    
export type itemListResponse = itemListResponseComposite & {
  headers: Headers;
}

export const getItemListUrl = (params?: ItemListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/item/?${stringifiedParams}` : `https://pokeapi.co/api/v2/item/`
}

export const itemList = async (params?: ItemListParams, options?: RequestInit): Promise<itemListResponse> => {
  
  const res = await fetch(getItemListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: itemListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as itemListResponse
}



export const getItemListQueryKey = (params?: ItemListParams,) => {
    return [`https://pokeapi.co/api/v2/item/`, ...(params ? [params]: [])] as const;
    }

    
export const getItemListQueryOptions = <TData = Awaited<ReturnType<typeof itemList>>, TError = unknown>(params?: ItemListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getItemListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof itemList>>> = ({ signal }) => itemList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof itemList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ItemListQueryResult = NonNullable<Awaited<ReturnType<typeof itemList>>>
export type ItemListQueryError = unknown


export function useItemList<TData = Awaited<ReturnType<typeof itemList>>, TError = unknown>(
 params: undefined |  ItemListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemList>>,
          TError,
          Awaited<ReturnType<typeof itemList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useItemList<TData = Awaited<ReturnType<typeof itemList>>, TError = unknown>(
 params?: ItemListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemList>>,
          TError,
          Awaited<ReturnType<typeof itemList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useItemList<TData = Awaited<ReturnType<typeof itemList>>, TError = unknown>(
 params?: ItemListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List items
 */

export function useItemList<TData = Awaited<ReturnType<typeof itemList>>, TError = unknown>(
 params?: ItemListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getItemListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * An item is an object in the games which the player can pick up, keep in their bag, and use in some manner. They have various uses, including healing, powering up, helping catch PokÃ©mon, or to access a new area.
 * @summary Get item
 */
export type itemRetrieveResponse200 = {
  data: ItemDetail
  status: 200
}
    
export type itemRetrieveResponseComposite = itemRetrieveResponse200;
    
export type itemRetrieveResponse = itemRetrieveResponseComposite & {
  headers: Headers;
}

export const getItemRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/item/${id}/`
}

export const itemRetrieve = async (id: string, options?: RequestInit): Promise<itemRetrieveResponse> => {
  
  const res = await fetch(getItemRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: itemRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as itemRetrieveResponse
}



export const getItemRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/item/${id}/`] as const;
    }

    
export const getItemRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof itemRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getItemRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof itemRetrieve>>> = ({ signal }) => itemRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof itemRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ItemRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof itemRetrieve>>>
export type ItemRetrieveQueryError = unknown


export function useItemRetrieve<TData = Awaited<ReturnType<typeof itemRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useItemRetrieve<TData = Awaited<ReturnType<typeof itemRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useItemRetrieve<TData = Awaited<ReturnType<typeof itemRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get item
 */

export function useItemRetrieve<TData = Awaited<ReturnType<typeof itemRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getItemRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Item categories determine where items will be placed in the players bag.
 * @summary List item categories
 */
export type itemCategoryListResponse200 = {
  data: PaginatedItemCategorySummaryList
  status: 200
}
    
export type itemCategoryListResponseComposite = itemCategoryListResponse200;
    
export type itemCategoryListResponse = itemCategoryListResponseComposite & {
  headers: Headers;
}

export const getItemCategoryListUrl = (params?: ItemCategoryListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/item-category/?${stringifiedParams}` : `https://pokeapi.co/api/v2/item-category/`
}

export const itemCategoryList = async (params?: ItemCategoryListParams, options?: RequestInit): Promise<itemCategoryListResponse> => {
  
  const res = await fetch(getItemCategoryListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: itemCategoryListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as itemCategoryListResponse
}



export const getItemCategoryListQueryKey = (params?: ItemCategoryListParams,) => {
    return [`https://pokeapi.co/api/v2/item-category/`, ...(params ? [params]: [])] as const;
    }

    
export const getItemCategoryListQueryOptions = <TData = Awaited<ReturnType<typeof itemCategoryList>>, TError = unknown>(params?: ItemCategoryListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemCategoryList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getItemCategoryListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof itemCategoryList>>> = ({ signal }) => itemCategoryList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof itemCategoryList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ItemCategoryListQueryResult = NonNullable<Awaited<ReturnType<typeof itemCategoryList>>>
export type ItemCategoryListQueryError = unknown


export function useItemCategoryList<TData = Awaited<ReturnType<typeof itemCategoryList>>, TError = unknown>(
 params: undefined |  ItemCategoryListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemCategoryList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemCategoryList>>,
          TError,
          Awaited<ReturnType<typeof itemCategoryList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useItemCategoryList<TData = Awaited<ReturnType<typeof itemCategoryList>>, TError = unknown>(
 params?: ItemCategoryListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemCategoryList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemCategoryList>>,
          TError,
          Awaited<ReturnType<typeof itemCategoryList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useItemCategoryList<TData = Awaited<ReturnType<typeof itemCategoryList>>, TError = unknown>(
 params?: ItemCategoryListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemCategoryList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List item categories
 */

export function useItemCategoryList<TData = Awaited<ReturnType<typeof itemCategoryList>>, TError = unknown>(
 params?: ItemCategoryListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemCategoryList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getItemCategoryListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Item categories determine where items will be placed in the players bag.
 * @summary Get item category
 */
export type itemCategoryRetrieveResponse200 = {
  data: ItemCategoryDetail
  status: 200
}
    
export type itemCategoryRetrieveResponseComposite = itemCategoryRetrieveResponse200;
    
export type itemCategoryRetrieveResponse = itemCategoryRetrieveResponseComposite & {
  headers: Headers;
}

export const getItemCategoryRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/item-category/${id}/`
}

export const itemCategoryRetrieve = async (id: string, options?: RequestInit): Promise<itemCategoryRetrieveResponse> => {
  
  const res = await fetch(getItemCategoryRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: itemCategoryRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as itemCategoryRetrieveResponse
}



export const getItemCategoryRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/item-category/${id}/`] as const;
    }

    
export const getItemCategoryRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof itemCategoryRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemCategoryRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getItemCategoryRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof itemCategoryRetrieve>>> = ({ signal }) => itemCategoryRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof itemCategoryRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ItemCategoryRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof itemCategoryRetrieve>>>
export type ItemCategoryRetrieveQueryError = unknown


export function useItemCategoryRetrieve<TData = Awaited<ReturnType<typeof itemCategoryRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemCategoryRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemCategoryRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemCategoryRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useItemCategoryRetrieve<TData = Awaited<ReturnType<typeof itemCategoryRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemCategoryRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemCategoryRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemCategoryRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useItemCategoryRetrieve<TData = Awaited<ReturnType<typeof itemCategoryRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemCategoryRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get item category
 */

export function useItemCategoryRetrieve<TData = Awaited<ReturnType<typeof itemCategoryRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemCategoryRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getItemCategoryRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Item attributes define particular aspects of items, e.g."usable in battle" or "consumable".
 * @summary List item attributes
 */
export type itemAttributeListResponse200 = {
  data: PaginatedItemAttributeSummaryList
  status: 200
}
    
export type itemAttributeListResponseComposite = itemAttributeListResponse200;
    
export type itemAttributeListResponse = itemAttributeListResponseComposite & {
  headers: Headers;
}

export const getItemAttributeListUrl = (params?: ItemAttributeListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/item-attribute/?${stringifiedParams}` : `https://pokeapi.co/api/v2/item-attribute/`
}

export const itemAttributeList = async (params?: ItemAttributeListParams, options?: RequestInit): Promise<itemAttributeListResponse> => {
  
  const res = await fetch(getItemAttributeListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: itemAttributeListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as itemAttributeListResponse
}



export const getItemAttributeListQueryKey = (params?: ItemAttributeListParams,) => {
    return [`https://pokeapi.co/api/v2/item-attribute/`, ...(params ? [params]: [])] as const;
    }

    
export const getItemAttributeListQueryOptions = <TData = Awaited<ReturnType<typeof itemAttributeList>>, TError = unknown>(params?: ItemAttributeListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemAttributeList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getItemAttributeListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof itemAttributeList>>> = ({ signal }) => itemAttributeList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof itemAttributeList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ItemAttributeListQueryResult = NonNullable<Awaited<ReturnType<typeof itemAttributeList>>>
export type ItemAttributeListQueryError = unknown


export function useItemAttributeList<TData = Awaited<ReturnType<typeof itemAttributeList>>, TError = unknown>(
 params: undefined |  ItemAttributeListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemAttributeList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemAttributeList>>,
          TError,
          Awaited<ReturnType<typeof itemAttributeList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useItemAttributeList<TData = Awaited<ReturnType<typeof itemAttributeList>>, TError = unknown>(
 params?: ItemAttributeListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemAttributeList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemAttributeList>>,
          TError,
          Awaited<ReturnType<typeof itemAttributeList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useItemAttributeList<TData = Awaited<ReturnType<typeof itemAttributeList>>, TError = unknown>(
 params?: ItemAttributeListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemAttributeList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List item attributes
 */

export function useItemAttributeList<TData = Awaited<ReturnType<typeof itemAttributeList>>, TError = unknown>(
 params?: ItemAttributeListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemAttributeList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getItemAttributeListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Item attributes define particular aspects of items, e.g."usable in battle" or "consumable".
 * @summary Get item attribute
 */
export type itemAttributeRetrieveResponse200 = {
  data: ItemAttributeDetail
  status: 200
}
    
export type itemAttributeRetrieveResponseComposite = itemAttributeRetrieveResponse200;
    
export type itemAttributeRetrieveResponse = itemAttributeRetrieveResponseComposite & {
  headers: Headers;
}

export const getItemAttributeRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/item-attribute/${id}/`
}

export const itemAttributeRetrieve = async (id: string, options?: RequestInit): Promise<itemAttributeRetrieveResponse> => {
  
  const res = await fetch(getItemAttributeRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: itemAttributeRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as itemAttributeRetrieveResponse
}



export const getItemAttributeRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/item-attribute/${id}/`] as const;
    }

    
export const getItemAttributeRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof itemAttributeRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemAttributeRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getItemAttributeRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof itemAttributeRetrieve>>> = ({ signal }) => itemAttributeRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof itemAttributeRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ItemAttributeRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof itemAttributeRetrieve>>>
export type ItemAttributeRetrieveQueryError = unknown


export function useItemAttributeRetrieve<TData = Awaited<ReturnType<typeof itemAttributeRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemAttributeRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemAttributeRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemAttributeRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useItemAttributeRetrieve<TData = Awaited<ReturnType<typeof itemAttributeRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemAttributeRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemAttributeRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemAttributeRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useItemAttributeRetrieve<TData = Awaited<ReturnType<typeof itemAttributeRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemAttributeRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get item attribute
 */

export function useItemAttributeRetrieve<TData = Awaited<ReturnType<typeof itemAttributeRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemAttributeRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getItemAttributeRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * The various effects of the move"Fling" when used with different items.
 * @summary List item fling effects
 */
export type itemFlingEffectListResponse200 = {
  data: PaginatedItemFlingEffectSummaryList
  status: 200
}
    
export type itemFlingEffectListResponseComposite = itemFlingEffectListResponse200;
    
export type itemFlingEffectListResponse = itemFlingEffectListResponseComposite & {
  headers: Headers;
}

export const getItemFlingEffectListUrl = (params?: ItemFlingEffectListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/item-fling-effect/?${stringifiedParams}` : `https://pokeapi.co/api/v2/item-fling-effect/`
}

export const itemFlingEffectList = async (params?: ItemFlingEffectListParams, options?: RequestInit): Promise<itemFlingEffectListResponse> => {
  
  const res = await fetch(getItemFlingEffectListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: itemFlingEffectListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as itemFlingEffectListResponse
}



export const getItemFlingEffectListQueryKey = (params?: ItemFlingEffectListParams,) => {
    return [`https://pokeapi.co/api/v2/item-fling-effect/`, ...(params ? [params]: [])] as const;
    }

    
export const getItemFlingEffectListQueryOptions = <TData = Awaited<ReturnType<typeof itemFlingEffectList>>, TError = unknown>(params?: ItemFlingEffectListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemFlingEffectList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getItemFlingEffectListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof itemFlingEffectList>>> = ({ signal }) => itemFlingEffectList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof itemFlingEffectList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ItemFlingEffectListQueryResult = NonNullable<Awaited<ReturnType<typeof itemFlingEffectList>>>
export type ItemFlingEffectListQueryError = unknown


export function useItemFlingEffectList<TData = Awaited<ReturnType<typeof itemFlingEffectList>>, TError = unknown>(
 params: undefined |  ItemFlingEffectListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemFlingEffectList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemFlingEffectList>>,
          TError,
          Awaited<ReturnType<typeof itemFlingEffectList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useItemFlingEffectList<TData = Awaited<ReturnType<typeof itemFlingEffectList>>, TError = unknown>(
 params?: ItemFlingEffectListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemFlingEffectList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemFlingEffectList>>,
          TError,
          Awaited<ReturnType<typeof itemFlingEffectList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useItemFlingEffectList<TData = Awaited<ReturnType<typeof itemFlingEffectList>>, TError = unknown>(
 params?: ItemFlingEffectListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemFlingEffectList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List item fling effects
 */

export function useItemFlingEffectList<TData = Awaited<ReturnType<typeof itemFlingEffectList>>, TError = unknown>(
 params?: ItemFlingEffectListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemFlingEffectList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getItemFlingEffectListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * The various effects of the move"Fling" when used with different items.
 * @summary Get item fling effect
 */
export type itemFlingEffectRetrieveResponse200 = {
  data: ItemFlingEffectDetail
  status: 200
}
    
export type itemFlingEffectRetrieveResponseComposite = itemFlingEffectRetrieveResponse200;
    
export type itemFlingEffectRetrieveResponse = itemFlingEffectRetrieveResponseComposite & {
  headers: Headers;
}

export const getItemFlingEffectRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/item-fling-effect/${id}/`
}

export const itemFlingEffectRetrieve = async (id: string, options?: RequestInit): Promise<itemFlingEffectRetrieveResponse> => {
  
  const res = await fetch(getItemFlingEffectRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: itemFlingEffectRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as itemFlingEffectRetrieveResponse
}



export const getItemFlingEffectRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/item-fling-effect/${id}/`] as const;
    }

    
export const getItemFlingEffectRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof itemFlingEffectRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemFlingEffectRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getItemFlingEffectRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof itemFlingEffectRetrieve>>> = ({ signal }) => itemFlingEffectRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof itemFlingEffectRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ItemFlingEffectRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof itemFlingEffectRetrieve>>>
export type ItemFlingEffectRetrieveQueryError = unknown


export function useItemFlingEffectRetrieve<TData = Awaited<ReturnType<typeof itemFlingEffectRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemFlingEffectRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemFlingEffectRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemFlingEffectRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useItemFlingEffectRetrieve<TData = Awaited<ReturnType<typeof itemFlingEffectRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemFlingEffectRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemFlingEffectRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemFlingEffectRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useItemFlingEffectRetrieve<TData = Awaited<ReturnType<typeof itemFlingEffectRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemFlingEffectRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get item fling effect
 */

export function useItemFlingEffectRetrieve<TData = Awaited<ReturnType<typeof itemFlingEffectRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemFlingEffectRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getItemFlingEffectRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Pockets within the players bag used for storing items by category.
 * @summary List item pockets
 */
export type itemPocketListResponse200 = {
  data: PaginatedItemPocketSummaryList
  status: 200
}
    
export type itemPocketListResponseComposite = itemPocketListResponse200;
    
export type itemPocketListResponse = itemPocketListResponseComposite & {
  headers: Headers;
}

export const getItemPocketListUrl = (params?: ItemPocketListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/item-pocket/?${stringifiedParams}` : `https://pokeapi.co/api/v2/item-pocket/`
}

export const itemPocketList = async (params?: ItemPocketListParams, options?: RequestInit): Promise<itemPocketListResponse> => {
  
  const res = await fetch(getItemPocketListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: itemPocketListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as itemPocketListResponse
}



export const getItemPocketListQueryKey = (params?: ItemPocketListParams,) => {
    return [`https://pokeapi.co/api/v2/item-pocket/`, ...(params ? [params]: [])] as const;
    }

    
export const getItemPocketListQueryOptions = <TData = Awaited<ReturnType<typeof itemPocketList>>, TError = unknown>(params?: ItemPocketListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemPocketList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getItemPocketListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof itemPocketList>>> = ({ signal }) => itemPocketList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof itemPocketList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ItemPocketListQueryResult = NonNullable<Awaited<ReturnType<typeof itemPocketList>>>
export type ItemPocketListQueryError = unknown


export function useItemPocketList<TData = Awaited<ReturnType<typeof itemPocketList>>, TError = unknown>(
 params: undefined |  ItemPocketListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemPocketList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemPocketList>>,
          TError,
          Awaited<ReturnType<typeof itemPocketList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useItemPocketList<TData = Awaited<ReturnType<typeof itemPocketList>>, TError = unknown>(
 params?: ItemPocketListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemPocketList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemPocketList>>,
          TError,
          Awaited<ReturnType<typeof itemPocketList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useItemPocketList<TData = Awaited<ReturnType<typeof itemPocketList>>, TError = unknown>(
 params?: ItemPocketListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemPocketList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List item pockets
 */

export function useItemPocketList<TData = Awaited<ReturnType<typeof itemPocketList>>, TError = unknown>(
 params?: ItemPocketListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemPocketList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getItemPocketListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Pockets within the players bag used for storing items by category.
 * @summary Get item pocket
 */
export type itemPocketRetrieveResponse200 = {
  data: ItemPocketDetail
  status: 200
}
    
export type itemPocketRetrieveResponseComposite = itemPocketRetrieveResponse200;
    
export type itemPocketRetrieveResponse = itemPocketRetrieveResponseComposite & {
  headers: Headers;
}

export const getItemPocketRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/item-pocket/${id}/`
}

export const itemPocketRetrieve = async (id: string, options?: RequestInit): Promise<itemPocketRetrieveResponse> => {
  
  const res = await fetch(getItemPocketRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: itemPocketRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as itemPocketRetrieveResponse
}



export const getItemPocketRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/item-pocket/${id}/`] as const;
    }

    
export const getItemPocketRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof itemPocketRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemPocketRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getItemPocketRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof itemPocketRetrieve>>> = ({ signal }) => itemPocketRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof itemPocketRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ItemPocketRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof itemPocketRetrieve>>>
export type ItemPocketRetrieveQueryError = unknown


export function useItemPocketRetrieve<TData = Awaited<ReturnType<typeof itemPocketRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemPocketRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemPocketRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemPocketRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useItemPocketRetrieve<TData = Awaited<ReturnType<typeof itemPocketRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemPocketRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemPocketRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemPocketRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useItemPocketRetrieve<TData = Awaited<ReturnType<typeof itemPocketRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemPocketRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get item pocket
 */

export function useItemPocketRetrieve<TData = Awaited<ReturnType<typeof itemPocketRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof itemPocketRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getItemPocketRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



