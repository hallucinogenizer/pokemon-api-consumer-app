/**
 * Generated by orval v7.8.0 🍺
 * Do not edit manually.
 * PokéAPI
 * All the Pokémon data you'll ever need in one place, easily accessible through a modern free open-source RESTful API.

## What is this?

This is a full RESTful API linked to an extensive database detailing everything about the Pokémon main game series.

We've covered everything from Pokémon to Berry Flavors.

## Where do I start?

We have awesome [documentation](https://pokeapi.co/docs/v2) on how to use this API. It takes minutes to get started.

This API will always be publicly available and will never require any extensive setup process to consume.

Created by [**Paul Hallett**](https://github.com/phalt) and other [**PokéAPI contributors***](https://github.com/PokeAPI/pokeapi#contributing) around the world. Pokémon and Pokémon character names are trademarks of Nintendo.
    
 * OpenAPI spec version: 2.7.0
 */
import {
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AbilityDetail,
  AbilityListParams,
  CharacteristicDetail,
  CharacteristicListParams,
  EggGroupDetail,
  EggGroupListParams,
  GenderDetail,
  GenderListParams,
  GrowthRateDetail,
  GrowthRateListParams,
  MoveDamageClassDetail,
  MoveDamageClassListParams,
  NatureDetail,
  NatureListParams,
  PaginatedAbilitySummaryList,
  PaginatedCharacteristicSummaryList,
  PaginatedEggGroupSummaryList,
  PaginatedGenderSummaryList,
  PaginatedGrowthRateSummaryList,
  PaginatedMoveDamageClassSummaryList,
  PaginatedNatureSummaryList,
  PaginatedPokeathlonStatSummaryList,
  PaginatedPokemonColorSummaryList,
  PaginatedPokemonFormSummaryList,
  PaginatedPokemonHabitatSummaryList,
  PaginatedPokemonShapeSummaryList,
  PaginatedPokemonSpeciesSummaryList,
  PaginatedPokemonSummaryList,
  PaginatedStatSummaryList,
  PaginatedTypeSummaryList,
  PokeathlonStatDetail,
  PokeathlonStatListParams,
  PokemonColorDetail,
  PokemonColorListParams,
  PokemonDetail,
  PokemonFormDetail,
  PokemonFormListParams,
  PokemonHabitatDetail,
  PokemonHabitatListParams,
  PokemonListParams,
  PokemonShapeDetail,
  PokemonShapeListParams,
  PokemonSpeciesDetail,
  PokemonSpeciesListParams,
  StatDetail,
  StatListParams,
  TypeDetail,
  TypeListParams
} from '.././model';





/**
 * Abilities provide passive effects for Pokémon in battle or in the overworld. Pokémon have multiple possible abilities but can have only one ability at a time. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Ability) for greater detail.
 */
export type abilityListResponse200 = {
  data: PaginatedAbilitySummaryList
  status: 200
}
    
export type abilityListResponseComposite = abilityListResponse200;
    
export type abilityListResponse = abilityListResponseComposite & {
  headers: Headers;
}

export const getAbilityListUrl = (params?: AbilityListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/ability/?${stringifiedParams}` : `https://pokeapi.co/api/v2/ability/`
}

export const abilityList = async (params?: AbilityListParams, options?: RequestInit): Promise<abilityListResponse> => {
  
  const res = await fetch(getAbilityListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: abilityListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as abilityListResponse
}



export const getAbilityListQueryKey = (params?: AbilityListParams,) => {
    return [`https://pokeapi.co/api/v2/ability/`, ...(params ? [params]: [])] as const;
    }

    
export const getAbilityListQueryOptions = <TData = Awaited<ReturnType<typeof abilityList>>, TError = unknown>(params?: AbilityListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof abilityList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAbilityListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof abilityList>>> = ({ signal }) => abilityList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof abilityList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AbilityListQueryResult = NonNullable<Awaited<ReturnType<typeof abilityList>>>
export type AbilityListQueryError = unknown


export function useAbilityList<TData = Awaited<ReturnType<typeof abilityList>>, TError = unknown>(
 params: undefined |  AbilityListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof abilityList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof abilityList>>,
          TError,
          Awaited<ReturnType<typeof abilityList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAbilityList<TData = Awaited<ReturnType<typeof abilityList>>, TError = unknown>(
 params?: AbilityListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof abilityList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof abilityList>>,
          TError,
          Awaited<ReturnType<typeof abilityList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAbilityList<TData = Awaited<ReturnType<typeof abilityList>>, TError = unknown>(
 params?: AbilityListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof abilityList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAbilityList<TData = Awaited<ReturnType<typeof abilityList>>, TError = unknown>(
 params?: AbilityListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof abilityList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAbilityListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Abilities provide passive effects for Pokémon in battle or in the overworld. Pokémon have multiple possible abilities but can have only one ability at a time. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Ability) for greater detail.
 */
export type abilityRetrieveResponse200 = {
  data: AbilityDetail
  status: 200
}
    
export type abilityRetrieveResponseComposite = abilityRetrieveResponse200;
    
export type abilityRetrieveResponse = abilityRetrieveResponseComposite & {
  headers: Headers;
}

export const getAbilityRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/ability/${id}/`
}

export const abilityRetrieve = async (id: string, options?: RequestInit): Promise<abilityRetrieveResponse> => {
  
  const res = await fetch(getAbilityRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: abilityRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as abilityRetrieveResponse
}



export const getAbilityRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/ability/${id}/`] as const;
    }

    
export const getAbilityRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof abilityRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof abilityRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAbilityRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof abilityRetrieve>>> = ({ signal }) => abilityRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof abilityRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AbilityRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof abilityRetrieve>>>
export type AbilityRetrieveQueryError = unknown


export function useAbilityRetrieve<TData = Awaited<ReturnType<typeof abilityRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof abilityRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof abilityRetrieve>>,
          TError,
          Awaited<ReturnType<typeof abilityRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAbilityRetrieve<TData = Awaited<ReturnType<typeof abilityRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof abilityRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof abilityRetrieve>>,
          TError,
          Awaited<ReturnType<typeof abilityRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAbilityRetrieve<TData = Awaited<ReturnType<typeof abilityRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof abilityRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAbilityRetrieve<TData = Awaited<ReturnType<typeof abilityRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof abilityRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAbilityRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Characteristics indicate which stat contains a Pokémon's highest IV. A Pokémon's Characteristic is determined by the remainder of its highest IV divided by 5 (gene_modulo). Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Characteristic) for greater detail.
 * @summary List charecterictics
 */
export type characteristicListResponse200 = {
  data: PaginatedCharacteristicSummaryList
  status: 200
}
    
export type characteristicListResponseComposite = characteristicListResponse200;
    
export type characteristicListResponse = characteristicListResponseComposite & {
  headers: Headers;
}

export const getCharacteristicListUrl = (params?: CharacteristicListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/characteristic/?${stringifiedParams}` : `https://pokeapi.co/api/v2/characteristic/`
}

export const characteristicList = async (params?: CharacteristicListParams, options?: RequestInit): Promise<characteristicListResponse> => {
  
  const res = await fetch(getCharacteristicListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: characteristicListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as characteristicListResponse
}



export const getCharacteristicListQueryKey = (params?: CharacteristicListParams,) => {
    return [`https://pokeapi.co/api/v2/characteristic/`, ...(params ? [params]: [])] as const;
    }

    
export const getCharacteristicListQueryOptions = <TData = Awaited<ReturnType<typeof characteristicList>>, TError = unknown>(params?: CharacteristicListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof characteristicList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCharacteristicListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof characteristicList>>> = ({ signal }) => characteristicList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof characteristicList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CharacteristicListQueryResult = NonNullable<Awaited<ReturnType<typeof characteristicList>>>
export type CharacteristicListQueryError = unknown


export function useCharacteristicList<TData = Awaited<ReturnType<typeof characteristicList>>, TError = unknown>(
 params: undefined |  CharacteristicListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof characteristicList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof characteristicList>>,
          TError,
          Awaited<ReturnType<typeof characteristicList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCharacteristicList<TData = Awaited<ReturnType<typeof characteristicList>>, TError = unknown>(
 params?: CharacteristicListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof characteristicList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof characteristicList>>,
          TError,
          Awaited<ReturnType<typeof characteristicList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCharacteristicList<TData = Awaited<ReturnType<typeof characteristicList>>, TError = unknown>(
 params?: CharacteristicListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof characteristicList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List charecterictics
 */

export function useCharacteristicList<TData = Awaited<ReturnType<typeof characteristicList>>, TError = unknown>(
 params?: CharacteristicListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof characteristicList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCharacteristicListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Characteristics indicate which stat contains a Pokémon's highest IV. A Pokémon's Characteristic is determined by the remainder of its highest IV divided by 5 (gene_modulo). Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Characteristic) for greater detail.
 * @summary Get characteristic
 */
export type characteristicRetrieveResponse200 = {
  data: CharacteristicDetail
  status: 200
}
    
export type characteristicRetrieveResponseComposite = characteristicRetrieveResponse200;
    
export type characteristicRetrieveResponse = characteristicRetrieveResponseComposite & {
  headers: Headers;
}

export const getCharacteristicRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/characteristic/${id}/`
}

export const characteristicRetrieve = async (id: string, options?: RequestInit): Promise<characteristicRetrieveResponse> => {
  
  const res = await fetch(getCharacteristicRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: characteristicRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as characteristicRetrieveResponse
}



export const getCharacteristicRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/characteristic/${id}/`] as const;
    }

    
export const getCharacteristicRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof characteristicRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof characteristicRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCharacteristicRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof characteristicRetrieve>>> = ({ signal }) => characteristicRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof characteristicRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CharacteristicRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof characteristicRetrieve>>>
export type CharacteristicRetrieveQueryError = unknown


export function useCharacteristicRetrieve<TData = Awaited<ReturnType<typeof characteristicRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof characteristicRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof characteristicRetrieve>>,
          TError,
          Awaited<ReturnType<typeof characteristicRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCharacteristicRetrieve<TData = Awaited<ReturnType<typeof characteristicRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof characteristicRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof characteristicRetrieve>>,
          TError,
          Awaited<ReturnType<typeof characteristicRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCharacteristicRetrieve<TData = Awaited<ReturnType<typeof characteristicRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof characteristicRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get characteristic
 */

export function useCharacteristicRetrieve<TData = Awaited<ReturnType<typeof characteristicRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof characteristicRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCharacteristicRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Egg Groups are categories which determine which Pokémon are able to interbreed. Pokémon may belong to either one or two Egg Groups. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Egg_Group) for greater detail.
 * @summary List egg groups
 */
export type eggGroupListResponse200 = {
  data: PaginatedEggGroupSummaryList
  status: 200
}
    
export type eggGroupListResponseComposite = eggGroupListResponse200;
    
export type eggGroupListResponse = eggGroupListResponseComposite & {
  headers: Headers;
}

export const getEggGroupListUrl = (params?: EggGroupListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/egg-group/?${stringifiedParams}` : `https://pokeapi.co/api/v2/egg-group/`
}

export const eggGroupList = async (params?: EggGroupListParams, options?: RequestInit): Promise<eggGroupListResponse> => {
  
  const res = await fetch(getEggGroupListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: eggGroupListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as eggGroupListResponse
}



export const getEggGroupListQueryKey = (params?: EggGroupListParams,) => {
    return [`https://pokeapi.co/api/v2/egg-group/`, ...(params ? [params]: [])] as const;
    }

    
export const getEggGroupListQueryOptions = <TData = Awaited<ReturnType<typeof eggGroupList>>, TError = unknown>(params?: EggGroupListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eggGroupList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEggGroupListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof eggGroupList>>> = ({ signal }) => eggGroupList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof eggGroupList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EggGroupListQueryResult = NonNullable<Awaited<ReturnType<typeof eggGroupList>>>
export type EggGroupListQueryError = unknown


export function useEggGroupList<TData = Awaited<ReturnType<typeof eggGroupList>>, TError = unknown>(
 params: undefined |  EggGroupListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof eggGroupList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof eggGroupList>>,
          TError,
          Awaited<ReturnType<typeof eggGroupList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEggGroupList<TData = Awaited<ReturnType<typeof eggGroupList>>, TError = unknown>(
 params?: EggGroupListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eggGroupList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof eggGroupList>>,
          TError,
          Awaited<ReturnType<typeof eggGroupList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEggGroupList<TData = Awaited<ReturnType<typeof eggGroupList>>, TError = unknown>(
 params?: EggGroupListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eggGroupList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List egg groups
 */

export function useEggGroupList<TData = Awaited<ReturnType<typeof eggGroupList>>, TError = unknown>(
 params?: EggGroupListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eggGroupList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEggGroupListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Egg Groups are categories which determine which Pokémon are able to interbreed. Pokémon may belong to either one or two Egg Groups. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Egg_Group) for greater detail.
 * @summary Get egg group
 */
export type eggGroupRetrieveResponse200 = {
  data: EggGroupDetail
  status: 200
}
    
export type eggGroupRetrieveResponseComposite = eggGroupRetrieveResponse200;
    
export type eggGroupRetrieveResponse = eggGroupRetrieveResponseComposite & {
  headers: Headers;
}

export const getEggGroupRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/egg-group/${id}/`
}

export const eggGroupRetrieve = async (id: string, options?: RequestInit): Promise<eggGroupRetrieveResponse> => {
  
  const res = await fetch(getEggGroupRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: eggGroupRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as eggGroupRetrieveResponse
}



export const getEggGroupRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/egg-group/${id}/`] as const;
    }

    
export const getEggGroupRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof eggGroupRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eggGroupRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEggGroupRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof eggGroupRetrieve>>> = ({ signal }) => eggGroupRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof eggGroupRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EggGroupRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof eggGroupRetrieve>>>
export type EggGroupRetrieveQueryError = unknown


export function useEggGroupRetrieve<TData = Awaited<ReturnType<typeof eggGroupRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof eggGroupRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof eggGroupRetrieve>>,
          TError,
          Awaited<ReturnType<typeof eggGroupRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEggGroupRetrieve<TData = Awaited<ReturnType<typeof eggGroupRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eggGroupRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof eggGroupRetrieve>>,
          TError,
          Awaited<ReturnType<typeof eggGroupRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEggGroupRetrieve<TData = Awaited<ReturnType<typeof eggGroupRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eggGroupRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get egg group
 */

export function useEggGroupRetrieve<TData = Awaited<ReturnType<typeof eggGroupRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eggGroupRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEggGroupRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Genders were introduced in Generation II for the purposes of breeding Pokémon but can also result in visual differences or even different evolutionary lines. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Gender) for greater detail.
 * @summary List genders
 */
export type genderListResponse200 = {
  data: PaginatedGenderSummaryList
  status: 200
}
    
export type genderListResponseComposite = genderListResponse200;
    
export type genderListResponse = genderListResponseComposite & {
  headers: Headers;
}

export const getGenderListUrl = (params?: GenderListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/gender/?${stringifiedParams}` : `https://pokeapi.co/api/v2/gender/`
}

export const genderList = async (params?: GenderListParams, options?: RequestInit): Promise<genderListResponse> => {
  
  const res = await fetch(getGenderListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: genderListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as genderListResponse
}



export const getGenderListQueryKey = (params?: GenderListParams,) => {
    return [`https://pokeapi.co/api/v2/gender/`, ...(params ? [params]: [])] as const;
    }

    
export const getGenderListQueryOptions = <TData = Awaited<ReturnType<typeof genderList>>, TError = unknown>(params?: GenderListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof genderList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGenderListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof genderList>>> = ({ signal }) => genderList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof genderList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GenderListQueryResult = NonNullable<Awaited<ReturnType<typeof genderList>>>
export type GenderListQueryError = unknown


export function useGenderList<TData = Awaited<ReturnType<typeof genderList>>, TError = unknown>(
 params: undefined |  GenderListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof genderList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof genderList>>,
          TError,
          Awaited<ReturnType<typeof genderList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGenderList<TData = Awaited<ReturnType<typeof genderList>>, TError = unknown>(
 params?: GenderListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof genderList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof genderList>>,
          TError,
          Awaited<ReturnType<typeof genderList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGenderList<TData = Awaited<ReturnType<typeof genderList>>, TError = unknown>(
 params?: GenderListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof genderList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List genders
 */

export function useGenderList<TData = Awaited<ReturnType<typeof genderList>>, TError = unknown>(
 params?: GenderListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof genderList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGenderListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Genders were introduced in Generation II for the purposes of breeding Pokémon but can also result in visual differences or even different evolutionary lines. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Gender) for greater detail.
 * @summary Get gender
 */
export type genderRetrieveResponse200 = {
  data: GenderDetail
  status: 200
}
    
export type genderRetrieveResponseComposite = genderRetrieveResponse200;
    
export type genderRetrieveResponse = genderRetrieveResponseComposite & {
  headers: Headers;
}

export const getGenderRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/gender/${id}/`
}

export const genderRetrieve = async (id: string, options?: RequestInit): Promise<genderRetrieveResponse> => {
  
  const res = await fetch(getGenderRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: genderRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as genderRetrieveResponse
}



export const getGenderRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/gender/${id}/`] as const;
    }

    
export const getGenderRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof genderRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof genderRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGenderRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof genderRetrieve>>> = ({ signal }) => genderRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof genderRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GenderRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof genderRetrieve>>>
export type GenderRetrieveQueryError = unknown


export function useGenderRetrieve<TData = Awaited<ReturnType<typeof genderRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof genderRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof genderRetrieve>>,
          TError,
          Awaited<ReturnType<typeof genderRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGenderRetrieve<TData = Awaited<ReturnType<typeof genderRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof genderRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof genderRetrieve>>,
          TError,
          Awaited<ReturnType<typeof genderRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGenderRetrieve<TData = Awaited<ReturnType<typeof genderRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof genderRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get gender
 */

export function useGenderRetrieve<TData = Awaited<ReturnType<typeof genderRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof genderRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGenderRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Growth rates are the speed with which Pokémon gain levels through experience. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Experience) for greater detail.
 * @summary List growth rates
 */
export type growthRateListResponse200 = {
  data: PaginatedGrowthRateSummaryList
  status: 200
}
    
export type growthRateListResponseComposite = growthRateListResponse200;
    
export type growthRateListResponse = growthRateListResponseComposite & {
  headers: Headers;
}

export const getGrowthRateListUrl = (params?: GrowthRateListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/growth-rate/?${stringifiedParams}` : `https://pokeapi.co/api/v2/growth-rate/`
}

export const growthRateList = async (params?: GrowthRateListParams, options?: RequestInit): Promise<growthRateListResponse> => {
  
  const res = await fetch(getGrowthRateListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: growthRateListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as growthRateListResponse
}



export const getGrowthRateListQueryKey = (params?: GrowthRateListParams,) => {
    return [`https://pokeapi.co/api/v2/growth-rate/`, ...(params ? [params]: [])] as const;
    }

    
export const getGrowthRateListQueryOptions = <TData = Awaited<ReturnType<typeof growthRateList>>, TError = unknown>(params?: GrowthRateListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof growthRateList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGrowthRateListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof growthRateList>>> = ({ signal }) => growthRateList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof growthRateList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GrowthRateListQueryResult = NonNullable<Awaited<ReturnType<typeof growthRateList>>>
export type GrowthRateListQueryError = unknown


export function useGrowthRateList<TData = Awaited<ReturnType<typeof growthRateList>>, TError = unknown>(
 params: undefined |  GrowthRateListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof growthRateList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof growthRateList>>,
          TError,
          Awaited<ReturnType<typeof growthRateList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGrowthRateList<TData = Awaited<ReturnType<typeof growthRateList>>, TError = unknown>(
 params?: GrowthRateListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof growthRateList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof growthRateList>>,
          TError,
          Awaited<ReturnType<typeof growthRateList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGrowthRateList<TData = Awaited<ReturnType<typeof growthRateList>>, TError = unknown>(
 params?: GrowthRateListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof growthRateList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List growth rates
 */

export function useGrowthRateList<TData = Awaited<ReturnType<typeof growthRateList>>, TError = unknown>(
 params?: GrowthRateListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof growthRateList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGrowthRateListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Growth rates are the speed with which Pokémon gain levels through experience. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Experience) for greater detail.
 * @summary Get growth rate
 */
export type growthRateRetrieveResponse200 = {
  data: GrowthRateDetail
  status: 200
}
    
export type growthRateRetrieveResponseComposite = growthRateRetrieveResponse200;
    
export type growthRateRetrieveResponse = growthRateRetrieveResponseComposite & {
  headers: Headers;
}

export const getGrowthRateRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/growth-rate/${id}/`
}

export const growthRateRetrieve = async (id: string, options?: RequestInit): Promise<growthRateRetrieveResponse> => {
  
  const res = await fetch(getGrowthRateRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: growthRateRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as growthRateRetrieveResponse
}



export const getGrowthRateRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/growth-rate/${id}/`] as const;
    }

    
export const getGrowthRateRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof growthRateRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof growthRateRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGrowthRateRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof growthRateRetrieve>>> = ({ signal }) => growthRateRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof growthRateRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GrowthRateRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof growthRateRetrieve>>>
export type GrowthRateRetrieveQueryError = unknown


export function useGrowthRateRetrieve<TData = Awaited<ReturnType<typeof growthRateRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof growthRateRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof growthRateRetrieve>>,
          TError,
          Awaited<ReturnType<typeof growthRateRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGrowthRateRetrieve<TData = Awaited<ReturnType<typeof growthRateRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof growthRateRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof growthRateRetrieve>>,
          TError,
          Awaited<ReturnType<typeof growthRateRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGrowthRateRetrieve<TData = Awaited<ReturnType<typeof growthRateRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof growthRateRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get growth rate
 */

export function useGrowthRateRetrieve<TData = Awaited<ReturnType<typeof growthRateRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof growthRateRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGrowthRateRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Damage classes moves can have, e.g. physical, special, or non-damaging.
 * @summary List move damage classes
 */
export type moveDamageClassListResponse200 = {
  data: PaginatedMoveDamageClassSummaryList
  status: 200
}
    
export type moveDamageClassListResponseComposite = moveDamageClassListResponse200;
    
export type moveDamageClassListResponse = moveDamageClassListResponseComposite & {
  headers: Headers;
}

export const getMoveDamageClassListUrl = (params?: MoveDamageClassListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/move-damage-class/?${stringifiedParams}` : `https://pokeapi.co/api/v2/move-damage-class/`
}

export const moveDamageClassList = async (params?: MoveDamageClassListParams, options?: RequestInit): Promise<moveDamageClassListResponse> => {
  
  const res = await fetch(getMoveDamageClassListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: moveDamageClassListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as moveDamageClassListResponse
}



export const getMoveDamageClassListQueryKey = (params?: MoveDamageClassListParams,) => {
    return [`https://pokeapi.co/api/v2/move-damage-class/`, ...(params ? [params]: [])] as const;
    }

    
export const getMoveDamageClassListQueryOptions = <TData = Awaited<ReturnType<typeof moveDamageClassList>>, TError = unknown>(params?: MoveDamageClassListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof moveDamageClassList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMoveDamageClassListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof moveDamageClassList>>> = ({ signal }) => moveDamageClassList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof moveDamageClassList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MoveDamageClassListQueryResult = NonNullable<Awaited<ReturnType<typeof moveDamageClassList>>>
export type MoveDamageClassListQueryError = unknown


export function useMoveDamageClassList<TData = Awaited<ReturnType<typeof moveDamageClassList>>, TError = unknown>(
 params: undefined |  MoveDamageClassListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof moveDamageClassList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveDamageClassList>>,
          TError,
          Awaited<ReturnType<typeof moveDamageClassList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMoveDamageClassList<TData = Awaited<ReturnType<typeof moveDamageClassList>>, TError = unknown>(
 params?: MoveDamageClassListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof moveDamageClassList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveDamageClassList>>,
          TError,
          Awaited<ReturnType<typeof moveDamageClassList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMoveDamageClassList<TData = Awaited<ReturnType<typeof moveDamageClassList>>, TError = unknown>(
 params?: MoveDamageClassListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof moveDamageClassList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List move damage classes
 */

export function useMoveDamageClassList<TData = Awaited<ReturnType<typeof moveDamageClassList>>, TError = unknown>(
 params?: MoveDamageClassListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof moveDamageClassList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMoveDamageClassListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Damage classes moves can have, e.g. physical, special, or non-damaging.
 * @summary Get move damage class
 */
export type moveDamageClassRetrieveResponse200 = {
  data: MoveDamageClassDetail
  status: 200
}
    
export type moveDamageClassRetrieveResponseComposite = moveDamageClassRetrieveResponse200;
    
export type moveDamageClassRetrieveResponse = moveDamageClassRetrieveResponseComposite & {
  headers: Headers;
}

export const getMoveDamageClassRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/move-damage-class/${id}/`
}

export const moveDamageClassRetrieve = async (id: string, options?: RequestInit): Promise<moveDamageClassRetrieveResponse> => {
  
  const res = await fetch(getMoveDamageClassRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: moveDamageClassRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as moveDamageClassRetrieveResponse
}



export const getMoveDamageClassRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/move-damage-class/${id}/`] as const;
    }

    
export const getMoveDamageClassRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof moveDamageClassRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof moveDamageClassRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMoveDamageClassRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof moveDamageClassRetrieve>>> = ({ signal }) => moveDamageClassRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof moveDamageClassRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MoveDamageClassRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof moveDamageClassRetrieve>>>
export type MoveDamageClassRetrieveQueryError = unknown


export function useMoveDamageClassRetrieve<TData = Awaited<ReturnType<typeof moveDamageClassRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof moveDamageClassRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveDamageClassRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveDamageClassRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMoveDamageClassRetrieve<TData = Awaited<ReturnType<typeof moveDamageClassRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof moveDamageClassRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveDamageClassRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveDamageClassRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMoveDamageClassRetrieve<TData = Awaited<ReturnType<typeof moveDamageClassRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof moveDamageClassRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get move damage class
 */

export function useMoveDamageClassRetrieve<TData = Awaited<ReturnType<typeof moveDamageClassRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof moveDamageClassRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMoveDamageClassRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Natures influence how a Pokémon's stats grow. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Nature) for greater detail.
 * @summary List natures
 */
export type natureListResponse200 = {
  data: PaginatedNatureSummaryList
  status: 200
}
    
export type natureListResponseComposite = natureListResponse200;
    
export type natureListResponse = natureListResponseComposite & {
  headers: Headers;
}

export const getNatureListUrl = (params?: NatureListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/nature/?${stringifiedParams}` : `https://pokeapi.co/api/v2/nature/`
}

export const natureList = async (params?: NatureListParams, options?: RequestInit): Promise<natureListResponse> => {
  
  const res = await fetch(getNatureListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: natureListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as natureListResponse
}



export const getNatureListQueryKey = (params?: NatureListParams,) => {
    return [`https://pokeapi.co/api/v2/nature/`, ...(params ? [params]: [])] as const;
    }

    
export const getNatureListQueryOptions = <TData = Awaited<ReturnType<typeof natureList>>, TError = unknown>(params?: NatureListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof natureList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNatureListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof natureList>>> = ({ signal }) => natureList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof natureList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type NatureListQueryResult = NonNullable<Awaited<ReturnType<typeof natureList>>>
export type NatureListQueryError = unknown


export function useNatureList<TData = Awaited<ReturnType<typeof natureList>>, TError = unknown>(
 params: undefined |  NatureListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof natureList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof natureList>>,
          TError,
          Awaited<ReturnType<typeof natureList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useNatureList<TData = Awaited<ReturnType<typeof natureList>>, TError = unknown>(
 params?: NatureListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof natureList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof natureList>>,
          TError,
          Awaited<ReturnType<typeof natureList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useNatureList<TData = Awaited<ReturnType<typeof natureList>>, TError = unknown>(
 params?: NatureListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof natureList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List natures
 */

export function useNatureList<TData = Awaited<ReturnType<typeof natureList>>, TError = unknown>(
 params?: NatureListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof natureList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getNatureListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Natures influence how a Pokémon's stats grow. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Nature) for greater detail.
 * @summary Get nature
 */
export type natureRetrieveResponse200 = {
  data: NatureDetail
  status: 200
}
    
export type natureRetrieveResponseComposite = natureRetrieveResponse200;
    
export type natureRetrieveResponse = natureRetrieveResponseComposite & {
  headers: Headers;
}

export const getNatureRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/nature/${id}/`
}

export const natureRetrieve = async (id: string, options?: RequestInit): Promise<natureRetrieveResponse> => {
  
  const res = await fetch(getNatureRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: natureRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as natureRetrieveResponse
}



export const getNatureRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/nature/${id}/`] as const;
    }

    
export const getNatureRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof natureRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof natureRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNatureRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof natureRetrieve>>> = ({ signal }) => natureRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof natureRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type NatureRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof natureRetrieve>>>
export type NatureRetrieveQueryError = unknown


export function useNatureRetrieve<TData = Awaited<ReturnType<typeof natureRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof natureRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof natureRetrieve>>,
          TError,
          Awaited<ReturnType<typeof natureRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useNatureRetrieve<TData = Awaited<ReturnType<typeof natureRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof natureRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof natureRetrieve>>,
          TError,
          Awaited<ReturnType<typeof natureRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useNatureRetrieve<TData = Awaited<ReturnType<typeof natureRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof natureRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get nature
 */

export function useNatureRetrieve<TData = Awaited<ReturnType<typeof natureRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof natureRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getNatureRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Pokémon are the creatures that inhabit the world of the Pokémon games. They can be caught using Pokéballs and trained by battling with other Pokémon. Each Pokémon belongs to a specific species but may take on a variant which makes it differ from other Pokémon of the same species, such as base stats, available abilities and typings. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9mon_(species)) for greater detail.
 * @summary List pokemon
 */
export type pokemonListResponse200 = {
  data: PaginatedPokemonSummaryList
  status: 200
}
    
export type pokemonListResponseComposite = pokemonListResponse200;
    
export type pokemonListResponse = pokemonListResponseComposite & {
  headers: Headers;
}

export const getPokemonListUrl = (params?: PokemonListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/pokemon/?${stringifiedParams}` : `https://pokeapi.co/api/v2/pokemon/`
}

export const pokemonList = async (params?: PokemonListParams, options?: RequestInit): Promise<pokemonListResponse> => {
  
  const res = await fetch(getPokemonListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: pokemonListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as pokemonListResponse
}



export const getPokemonListQueryKey = (params?: PokemonListParams,) => {
    return [`https://pokeapi.co/api/v2/pokemon/`, ...(params ? [params]: [])] as const;
    }

    
export const getPokemonListQueryOptions = <TData = Awaited<ReturnType<typeof pokemonList>>, TError = unknown>(params?: PokemonListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPokemonListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pokemonList>>> = ({ signal }) => pokemonList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pokemonList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PokemonListQueryResult = NonNullable<Awaited<ReturnType<typeof pokemonList>>>
export type PokemonListQueryError = unknown


export function usePokemonList<TData = Awaited<ReturnType<typeof pokemonList>>, TError = unknown>(
 params: undefined |  PokemonListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonList>>,
          TError,
          Awaited<ReturnType<typeof pokemonList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokemonList<TData = Awaited<ReturnType<typeof pokemonList>>, TError = unknown>(
 params?: PokemonListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonList>>,
          TError,
          Awaited<ReturnType<typeof pokemonList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokemonList<TData = Awaited<ReturnType<typeof pokemonList>>, TError = unknown>(
 params?: PokemonListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List pokemon
 */

export function usePokemonList<TData = Awaited<ReturnType<typeof pokemonList>>, TError = unknown>(
 params?: PokemonListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPokemonListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Pokémon are the creatures that inhabit the world of the Pokémon games. They can be caught using Pokéballs and trained by battling with other Pokémon. Each Pokémon belongs to a specific species but may take on a variant which makes it differ from other Pokémon of the same species, such as base stats, available abilities and typings. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9mon_(species)) for greater detail.
 * @summary Get pokemon
 */
export type pokemonRetrieveResponse200 = {
  data: PokemonDetail
  status: 200
}
    
export type pokemonRetrieveResponseComposite = pokemonRetrieveResponse200;
    
export type pokemonRetrieveResponse = pokemonRetrieveResponseComposite & {
  headers: Headers;
}

export const getPokemonRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/pokemon/${id}/`
}

export const pokemonRetrieve = async (id: string, options?: RequestInit): Promise<pokemonRetrieveResponse> => {
  
  const res = await fetch(getPokemonRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: pokemonRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as pokemonRetrieveResponse
}



export const getPokemonRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/pokemon/${id}/`] as const;
    }

    
export const getPokemonRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof pokemonRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPokemonRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pokemonRetrieve>>> = ({ signal }) => pokemonRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pokemonRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PokemonRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof pokemonRetrieve>>>
export type PokemonRetrieveQueryError = unknown


export function usePokemonRetrieve<TData = Awaited<ReturnType<typeof pokemonRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokemonRetrieve<TData = Awaited<ReturnType<typeof pokemonRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokemonRetrieve<TData = Awaited<ReturnType<typeof pokemonRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get pokemon
 */

export function usePokemonRetrieve<TData = Awaited<ReturnType<typeof pokemonRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPokemonRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Colors used for sorting Pokémon in a Pokédex. The color listed in the Pokédex is usually the color most apparent or covering each Pokémon's body. No orange category exists; Pokémon that are primarily orange are listed as red or brown.
 * @summary List pokemon colors
 */
export type pokemonColorListResponse200 = {
  data: PaginatedPokemonColorSummaryList
  status: 200
}
    
export type pokemonColorListResponseComposite = pokemonColorListResponse200;
    
export type pokemonColorListResponse = pokemonColorListResponseComposite & {
  headers: Headers;
}

export const getPokemonColorListUrl = (params?: PokemonColorListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/pokemon-color/?${stringifiedParams}` : `https://pokeapi.co/api/v2/pokemon-color/`
}

export const pokemonColorList = async (params?: PokemonColorListParams, options?: RequestInit): Promise<pokemonColorListResponse> => {
  
  const res = await fetch(getPokemonColorListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: pokemonColorListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as pokemonColorListResponse
}



export const getPokemonColorListQueryKey = (params?: PokemonColorListParams,) => {
    return [`https://pokeapi.co/api/v2/pokemon-color/`, ...(params ? [params]: [])] as const;
    }

    
export const getPokemonColorListQueryOptions = <TData = Awaited<ReturnType<typeof pokemonColorList>>, TError = unknown>(params?: PokemonColorListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonColorList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPokemonColorListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pokemonColorList>>> = ({ signal }) => pokemonColorList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pokemonColorList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PokemonColorListQueryResult = NonNullable<Awaited<ReturnType<typeof pokemonColorList>>>
export type PokemonColorListQueryError = unknown


export function usePokemonColorList<TData = Awaited<ReturnType<typeof pokemonColorList>>, TError = unknown>(
 params: undefined |  PokemonColorListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonColorList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonColorList>>,
          TError,
          Awaited<ReturnType<typeof pokemonColorList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokemonColorList<TData = Awaited<ReturnType<typeof pokemonColorList>>, TError = unknown>(
 params?: PokemonColorListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonColorList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonColorList>>,
          TError,
          Awaited<ReturnType<typeof pokemonColorList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokemonColorList<TData = Awaited<ReturnType<typeof pokemonColorList>>, TError = unknown>(
 params?: PokemonColorListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonColorList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List pokemon colors
 */

export function usePokemonColorList<TData = Awaited<ReturnType<typeof pokemonColorList>>, TError = unknown>(
 params?: PokemonColorListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonColorList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPokemonColorListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Colors used for sorting Pokémon in a Pokédex. The color listed in the Pokédex is usually the color most apparent or covering each Pokémon's body. No orange category exists; Pokémon that are primarily orange are listed as red or brown.
 * @summary Get pokemon color
 */
export type pokemonColorRetrieveResponse200 = {
  data: PokemonColorDetail
  status: 200
}
    
export type pokemonColorRetrieveResponseComposite = pokemonColorRetrieveResponse200;
    
export type pokemonColorRetrieveResponse = pokemonColorRetrieveResponseComposite & {
  headers: Headers;
}

export const getPokemonColorRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/pokemon-color/${id}/`
}

export const pokemonColorRetrieve = async (id: string, options?: RequestInit): Promise<pokemonColorRetrieveResponse> => {
  
  const res = await fetch(getPokemonColorRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: pokemonColorRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as pokemonColorRetrieveResponse
}



export const getPokemonColorRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/pokemon-color/${id}/`] as const;
    }

    
export const getPokemonColorRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof pokemonColorRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonColorRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPokemonColorRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pokemonColorRetrieve>>> = ({ signal }) => pokemonColorRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pokemonColorRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PokemonColorRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof pokemonColorRetrieve>>>
export type PokemonColorRetrieveQueryError = unknown


export function usePokemonColorRetrieve<TData = Awaited<ReturnType<typeof pokemonColorRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonColorRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonColorRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonColorRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokemonColorRetrieve<TData = Awaited<ReturnType<typeof pokemonColorRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonColorRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonColorRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonColorRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokemonColorRetrieve<TData = Awaited<ReturnType<typeof pokemonColorRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonColorRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get pokemon color
 */

export function usePokemonColorRetrieve<TData = Awaited<ReturnType<typeof pokemonColorRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonColorRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPokemonColorRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Some Pokémon may appear in one of multiple, visually different forms. These differences are purely cosmetic. For variations within a Pokémon species, which do differ in more than just visuals, the 'Pokémon' entity is used to represent such a variety.
 * @summary List pokemon forms
 */
export type pokemonFormListResponse200 = {
  data: PaginatedPokemonFormSummaryList
  status: 200
}
    
export type pokemonFormListResponseComposite = pokemonFormListResponse200;
    
export type pokemonFormListResponse = pokemonFormListResponseComposite & {
  headers: Headers;
}

export const getPokemonFormListUrl = (params?: PokemonFormListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/pokemon-form/?${stringifiedParams}` : `https://pokeapi.co/api/v2/pokemon-form/`
}

export const pokemonFormList = async (params?: PokemonFormListParams, options?: RequestInit): Promise<pokemonFormListResponse> => {
  
  const res = await fetch(getPokemonFormListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: pokemonFormListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as pokemonFormListResponse
}



export const getPokemonFormListQueryKey = (params?: PokemonFormListParams,) => {
    return [`https://pokeapi.co/api/v2/pokemon-form/`, ...(params ? [params]: [])] as const;
    }

    
export const getPokemonFormListQueryOptions = <TData = Awaited<ReturnType<typeof pokemonFormList>>, TError = unknown>(params?: PokemonFormListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonFormList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPokemonFormListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pokemonFormList>>> = ({ signal }) => pokemonFormList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pokemonFormList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PokemonFormListQueryResult = NonNullable<Awaited<ReturnType<typeof pokemonFormList>>>
export type PokemonFormListQueryError = unknown


export function usePokemonFormList<TData = Awaited<ReturnType<typeof pokemonFormList>>, TError = unknown>(
 params: undefined |  PokemonFormListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonFormList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonFormList>>,
          TError,
          Awaited<ReturnType<typeof pokemonFormList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokemonFormList<TData = Awaited<ReturnType<typeof pokemonFormList>>, TError = unknown>(
 params?: PokemonFormListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonFormList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonFormList>>,
          TError,
          Awaited<ReturnType<typeof pokemonFormList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokemonFormList<TData = Awaited<ReturnType<typeof pokemonFormList>>, TError = unknown>(
 params?: PokemonFormListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonFormList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List pokemon forms
 */

export function usePokemonFormList<TData = Awaited<ReturnType<typeof pokemonFormList>>, TError = unknown>(
 params?: PokemonFormListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonFormList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPokemonFormListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Some Pokémon may appear in one of multiple, visually different forms. These differences are purely cosmetic. For variations within a Pokémon species, which do differ in more than just visuals, the 'Pokémon' entity is used to represent such a variety.
 * @summary Get pokemon form
 */
export type pokemonFormRetrieveResponse200 = {
  data: PokemonFormDetail
  status: 200
}
    
export type pokemonFormRetrieveResponseComposite = pokemonFormRetrieveResponse200;
    
export type pokemonFormRetrieveResponse = pokemonFormRetrieveResponseComposite & {
  headers: Headers;
}

export const getPokemonFormRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/pokemon-form/${id}/`
}

export const pokemonFormRetrieve = async (id: string, options?: RequestInit): Promise<pokemonFormRetrieveResponse> => {
  
  const res = await fetch(getPokemonFormRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: pokemonFormRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as pokemonFormRetrieveResponse
}



export const getPokemonFormRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/pokemon-form/${id}/`] as const;
    }

    
export const getPokemonFormRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof pokemonFormRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonFormRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPokemonFormRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pokemonFormRetrieve>>> = ({ signal }) => pokemonFormRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pokemonFormRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PokemonFormRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof pokemonFormRetrieve>>>
export type PokemonFormRetrieveQueryError = unknown


export function usePokemonFormRetrieve<TData = Awaited<ReturnType<typeof pokemonFormRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonFormRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonFormRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonFormRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokemonFormRetrieve<TData = Awaited<ReturnType<typeof pokemonFormRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonFormRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonFormRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonFormRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokemonFormRetrieve<TData = Awaited<ReturnType<typeof pokemonFormRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonFormRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get pokemon form
 */

export function usePokemonFormRetrieve<TData = Awaited<ReturnType<typeof pokemonFormRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonFormRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPokemonFormRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Habitats are generally different terrain Pokémon can be found in but can also be areas designated for rare or legendary Pokémon.
 * @summary List pokemom habitas
 */
export type pokemonHabitatListResponse200 = {
  data: PaginatedPokemonHabitatSummaryList
  status: 200
}
    
export type pokemonHabitatListResponseComposite = pokemonHabitatListResponse200;
    
export type pokemonHabitatListResponse = pokemonHabitatListResponseComposite & {
  headers: Headers;
}

export const getPokemonHabitatListUrl = (params?: PokemonHabitatListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/pokemon-habitat/?${stringifiedParams}` : `https://pokeapi.co/api/v2/pokemon-habitat/`
}

export const pokemonHabitatList = async (params?: PokemonHabitatListParams, options?: RequestInit): Promise<pokemonHabitatListResponse> => {
  
  const res = await fetch(getPokemonHabitatListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: pokemonHabitatListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as pokemonHabitatListResponse
}



export const getPokemonHabitatListQueryKey = (params?: PokemonHabitatListParams,) => {
    return [`https://pokeapi.co/api/v2/pokemon-habitat/`, ...(params ? [params]: [])] as const;
    }

    
export const getPokemonHabitatListQueryOptions = <TData = Awaited<ReturnType<typeof pokemonHabitatList>>, TError = unknown>(params?: PokemonHabitatListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonHabitatList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPokemonHabitatListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pokemonHabitatList>>> = ({ signal }) => pokemonHabitatList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pokemonHabitatList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PokemonHabitatListQueryResult = NonNullable<Awaited<ReturnType<typeof pokemonHabitatList>>>
export type PokemonHabitatListQueryError = unknown


export function usePokemonHabitatList<TData = Awaited<ReturnType<typeof pokemonHabitatList>>, TError = unknown>(
 params: undefined |  PokemonHabitatListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonHabitatList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonHabitatList>>,
          TError,
          Awaited<ReturnType<typeof pokemonHabitatList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokemonHabitatList<TData = Awaited<ReturnType<typeof pokemonHabitatList>>, TError = unknown>(
 params?: PokemonHabitatListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonHabitatList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonHabitatList>>,
          TError,
          Awaited<ReturnType<typeof pokemonHabitatList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokemonHabitatList<TData = Awaited<ReturnType<typeof pokemonHabitatList>>, TError = unknown>(
 params?: PokemonHabitatListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonHabitatList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List pokemom habitas
 */

export function usePokemonHabitatList<TData = Awaited<ReturnType<typeof pokemonHabitatList>>, TError = unknown>(
 params?: PokemonHabitatListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonHabitatList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPokemonHabitatListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Habitats are generally different terrain Pokémon can be found in but can also be areas designated for rare or legendary Pokémon.
 * @summary Get pokemom habita
 */
export type pokemonHabitatRetrieveResponse200 = {
  data: PokemonHabitatDetail
  status: 200
}
    
export type pokemonHabitatRetrieveResponseComposite = pokemonHabitatRetrieveResponse200;
    
export type pokemonHabitatRetrieveResponse = pokemonHabitatRetrieveResponseComposite & {
  headers: Headers;
}

export const getPokemonHabitatRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/pokemon-habitat/${id}/`
}

export const pokemonHabitatRetrieve = async (id: string, options?: RequestInit): Promise<pokemonHabitatRetrieveResponse> => {
  
  const res = await fetch(getPokemonHabitatRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: pokemonHabitatRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as pokemonHabitatRetrieveResponse
}



export const getPokemonHabitatRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/pokemon-habitat/${id}/`] as const;
    }

    
export const getPokemonHabitatRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof pokemonHabitatRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonHabitatRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPokemonHabitatRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pokemonHabitatRetrieve>>> = ({ signal }) => pokemonHabitatRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pokemonHabitatRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PokemonHabitatRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof pokemonHabitatRetrieve>>>
export type PokemonHabitatRetrieveQueryError = unknown


export function usePokemonHabitatRetrieve<TData = Awaited<ReturnType<typeof pokemonHabitatRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonHabitatRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonHabitatRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonHabitatRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokemonHabitatRetrieve<TData = Awaited<ReturnType<typeof pokemonHabitatRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonHabitatRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonHabitatRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonHabitatRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokemonHabitatRetrieve<TData = Awaited<ReturnType<typeof pokemonHabitatRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonHabitatRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get pokemom habita
 */

export function usePokemonHabitatRetrieve<TData = Awaited<ReturnType<typeof pokemonHabitatRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonHabitatRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPokemonHabitatRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Shapes used for sorting Pokémon in a Pokédex.
 * @summary List pokemon shapes
 */
export type pokemonShapeListResponse200 = {
  data: PaginatedPokemonShapeSummaryList
  status: 200
}
    
export type pokemonShapeListResponseComposite = pokemonShapeListResponse200;
    
export type pokemonShapeListResponse = pokemonShapeListResponseComposite & {
  headers: Headers;
}

export const getPokemonShapeListUrl = (params?: PokemonShapeListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/pokemon-shape/?${stringifiedParams}` : `https://pokeapi.co/api/v2/pokemon-shape/`
}

export const pokemonShapeList = async (params?: PokemonShapeListParams, options?: RequestInit): Promise<pokemonShapeListResponse> => {
  
  const res = await fetch(getPokemonShapeListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: pokemonShapeListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as pokemonShapeListResponse
}



export const getPokemonShapeListQueryKey = (params?: PokemonShapeListParams,) => {
    return [`https://pokeapi.co/api/v2/pokemon-shape/`, ...(params ? [params]: [])] as const;
    }

    
export const getPokemonShapeListQueryOptions = <TData = Awaited<ReturnType<typeof pokemonShapeList>>, TError = unknown>(params?: PokemonShapeListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonShapeList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPokemonShapeListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pokemonShapeList>>> = ({ signal }) => pokemonShapeList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pokemonShapeList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PokemonShapeListQueryResult = NonNullable<Awaited<ReturnType<typeof pokemonShapeList>>>
export type PokemonShapeListQueryError = unknown


export function usePokemonShapeList<TData = Awaited<ReturnType<typeof pokemonShapeList>>, TError = unknown>(
 params: undefined |  PokemonShapeListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonShapeList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonShapeList>>,
          TError,
          Awaited<ReturnType<typeof pokemonShapeList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokemonShapeList<TData = Awaited<ReturnType<typeof pokemonShapeList>>, TError = unknown>(
 params?: PokemonShapeListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonShapeList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonShapeList>>,
          TError,
          Awaited<ReturnType<typeof pokemonShapeList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokemonShapeList<TData = Awaited<ReturnType<typeof pokemonShapeList>>, TError = unknown>(
 params?: PokemonShapeListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonShapeList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List pokemon shapes
 */

export function usePokemonShapeList<TData = Awaited<ReturnType<typeof pokemonShapeList>>, TError = unknown>(
 params?: PokemonShapeListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonShapeList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPokemonShapeListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Shapes used for sorting Pokémon in a Pokédex.
 * @summary Get pokemon shape
 */
export type pokemonShapeRetrieveResponse200 = {
  data: PokemonShapeDetail
  status: 200
}
    
export type pokemonShapeRetrieveResponseComposite = pokemonShapeRetrieveResponse200;
    
export type pokemonShapeRetrieveResponse = pokemonShapeRetrieveResponseComposite & {
  headers: Headers;
}

export const getPokemonShapeRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/pokemon-shape/${id}/`
}

export const pokemonShapeRetrieve = async (id: string, options?: RequestInit): Promise<pokemonShapeRetrieveResponse> => {
  
  const res = await fetch(getPokemonShapeRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: pokemonShapeRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as pokemonShapeRetrieveResponse
}



export const getPokemonShapeRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/pokemon-shape/${id}/`] as const;
    }

    
export const getPokemonShapeRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof pokemonShapeRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonShapeRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPokemonShapeRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pokemonShapeRetrieve>>> = ({ signal }) => pokemonShapeRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pokemonShapeRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PokemonShapeRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof pokemonShapeRetrieve>>>
export type PokemonShapeRetrieveQueryError = unknown


export function usePokemonShapeRetrieve<TData = Awaited<ReturnType<typeof pokemonShapeRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonShapeRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonShapeRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonShapeRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokemonShapeRetrieve<TData = Awaited<ReturnType<typeof pokemonShapeRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonShapeRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonShapeRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonShapeRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokemonShapeRetrieve<TData = Awaited<ReturnType<typeof pokemonShapeRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonShapeRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get pokemon shape
 */

export function usePokemonShapeRetrieve<TData = Awaited<ReturnType<typeof pokemonShapeRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonShapeRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPokemonShapeRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * A Pokémon Species forms the basis for at least one Pokémon. Attributes of a Pokémon species are shared across all varieties of Pokémon within the species. A good example is Wormadam; Wormadam is the species which can be found in three different varieties, Wormadam-Trash, Wormadam-Sandy and Wormadam-Plant.
 * @summary List pokemon species
 */
export type pokemonSpeciesListResponse200 = {
  data: PaginatedPokemonSpeciesSummaryList
  status: 200
}
    
export type pokemonSpeciesListResponseComposite = pokemonSpeciesListResponse200;
    
export type pokemonSpeciesListResponse = pokemonSpeciesListResponseComposite & {
  headers: Headers;
}

export const getPokemonSpeciesListUrl = (params?: PokemonSpeciesListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/pokemon-species/?${stringifiedParams}` : `https://pokeapi.co/api/v2/pokemon-species/`
}

export const pokemonSpeciesList = async (params?: PokemonSpeciesListParams, options?: RequestInit): Promise<pokemonSpeciesListResponse> => {
  
  const res = await fetch(getPokemonSpeciesListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: pokemonSpeciesListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as pokemonSpeciesListResponse
}



export const getPokemonSpeciesListQueryKey = (params?: PokemonSpeciesListParams,) => {
    return [`https://pokeapi.co/api/v2/pokemon-species/`, ...(params ? [params]: [])] as const;
    }

    
export const getPokemonSpeciesListQueryOptions = <TData = Awaited<ReturnType<typeof pokemonSpeciesList>>, TError = unknown>(params?: PokemonSpeciesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonSpeciesList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPokemonSpeciesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pokemonSpeciesList>>> = ({ signal }) => pokemonSpeciesList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pokemonSpeciesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PokemonSpeciesListQueryResult = NonNullable<Awaited<ReturnType<typeof pokemonSpeciesList>>>
export type PokemonSpeciesListQueryError = unknown


export function usePokemonSpeciesList<TData = Awaited<ReturnType<typeof pokemonSpeciesList>>, TError = unknown>(
 params: undefined |  PokemonSpeciesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonSpeciesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonSpeciesList>>,
          TError,
          Awaited<ReturnType<typeof pokemonSpeciesList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokemonSpeciesList<TData = Awaited<ReturnType<typeof pokemonSpeciesList>>, TError = unknown>(
 params?: PokemonSpeciesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonSpeciesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonSpeciesList>>,
          TError,
          Awaited<ReturnType<typeof pokemonSpeciesList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokemonSpeciesList<TData = Awaited<ReturnType<typeof pokemonSpeciesList>>, TError = unknown>(
 params?: PokemonSpeciesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonSpeciesList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List pokemon species
 */

export function usePokemonSpeciesList<TData = Awaited<ReturnType<typeof pokemonSpeciesList>>, TError = unknown>(
 params?: PokemonSpeciesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonSpeciesList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPokemonSpeciesListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * A Pokémon Species forms the basis for at least one Pokémon. Attributes of a Pokémon species are shared across all varieties of Pokémon within the species. A good example is Wormadam; Wormadam is the species which can be found in three different varieties, Wormadam-Trash, Wormadam-Sandy and Wormadam-Plant.
 * @summary Get pokemon species
 */
export type pokemonSpeciesRetrieveResponse200 = {
  data: PokemonSpeciesDetail
  status: 200
}
    
export type pokemonSpeciesRetrieveResponseComposite = pokemonSpeciesRetrieveResponse200;
    
export type pokemonSpeciesRetrieveResponse = pokemonSpeciesRetrieveResponseComposite & {
  headers: Headers;
}

export const getPokemonSpeciesRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/pokemon-species/${id}/`
}

export const pokemonSpeciesRetrieve = async (id: string, options?: RequestInit): Promise<pokemonSpeciesRetrieveResponse> => {
  
  const res = await fetch(getPokemonSpeciesRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: pokemonSpeciesRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as pokemonSpeciesRetrieveResponse
}



export const getPokemonSpeciesRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/pokemon-species/${id}/`] as const;
    }

    
export const getPokemonSpeciesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPokemonSpeciesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>> = ({ signal }) => pokemonSpeciesRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PokemonSpeciesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>>
export type PokemonSpeciesRetrieveQueryError = unknown


export function usePokemonSpeciesRetrieve<TData = Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokemonSpeciesRetrieve<TData = Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokemonSpeciesRetrieve<TData = Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get pokemon species
 */

export function usePokemonSpeciesRetrieve<TData = Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPokemonSpeciesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Pokeathlon Stats are different attributes of a Pokémon's performance in Pokéathlons. In Pokéathlons, competitions happen on different courses; one for each of the different Pokéathlon stats. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9athlon) for greater detail.
 * @summary List pokeathlon stats
 */
export type pokeathlonStatListResponse200 = {
  data: PaginatedPokeathlonStatSummaryList
  status: 200
}
    
export type pokeathlonStatListResponseComposite = pokeathlonStatListResponse200;
    
export type pokeathlonStatListResponse = pokeathlonStatListResponseComposite & {
  headers: Headers;
}

export const getPokeathlonStatListUrl = (params?: PokeathlonStatListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/pokeathlon-stat/?${stringifiedParams}` : `https://pokeapi.co/api/v2/pokeathlon-stat/`
}

export const pokeathlonStatList = async (params?: PokeathlonStatListParams, options?: RequestInit): Promise<pokeathlonStatListResponse> => {
  
  const res = await fetch(getPokeathlonStatListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: pokeathlonStatListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as pokeathlonStatListResponse
}



export const getPokeathlonStatListQueryKey = (params?: PokeathlonStatListParams,) => {
    return [`https://pokeapi.co/api/v2/pokeathlon-stat/`, ...(params ? [params]: [])] as const;
    }

    
export const getPokeathlonStatListQueryOptions = <TData = Awaited<ReturnType<typeof pokeathlonStatList>>, TError = unknown>(params?: PokeathlonStatListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokeathlonStatList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPokeathlonStatListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pokeathlonStatList>>> = ({ signal }) => pokeathlonStatList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pokeathlonStatList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PokeathlonStatListQueryResult = NonNullable<Awaited<ReturnType<typeof pokeathlonStatList>>>
export type PokeathlonStatListQueryError = unknown


export function usePokeathlonStatList<TData = Awaited<ReturnType<typeof pokeathlonStatList>>, TError = unknown>(
 params: undefined |  PokeathlonStatListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokeathlonStatList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokeathlonStatList>>,
          TError,
          Awaited<ReturnType<typeof pokeathlonStatList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokeathlonStatList<TData = Awaited<ReturnType<typeof pokeathlonStatList>>, TError = unknown>(
 params?: PokeathlonStatListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokeathlonStatList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokeathlonStatList>>,
          TError,
          Awaited<ReturnType<typeof pokeathlonStatList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokeathlonStatList<TData = Awaited<ReturnType<typeof pokeathlonStatList>>, TError = unknown>(
 params?: PokeathlonStatListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokeathlonStatList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List pokeathlon stats
 */

export function usePokeathlonStatList<TData = Awaited<ReturnType<typeof pokeathlonStatList>>, TError = unknown>(
 params?: PokeathlonStatListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokeathlonStatList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPokeathlonStatListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Pokeathlon Stats are different attributes of a Pokémon's performance in Pokéathlons. In Pokéathlons, competitions happen on different courses; one for each of the different Pokéathlon stats. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9athlon) for greater detail.
 * @summary Get pokeathlon stat
 */
export type pokeathlonStatRetrieveResponse200 = {
  data: PokeathlonStatDetail
  status: 200
}
    
export type pokeathlonStatRetrieveResponseComposite = pokeathlonStatRetrieveResponse200;
    
export type pokeathlonStatRetrieveResponse = pokeathlonStatRetrieveResponseComposite & {
  headers: Headers;
}

export const getPokeathlonStatRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/pokeathlon-stat/${id}/`
}

export const pokeathlonStatRetrieve = async (id: string, options?: RequestInit): Promise<pokeathlonStatRetrieveResponse> => {
  
  const res = await fetch(getPokeathlonStatRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: pokeathlonStatRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as pokeathlonStatRetrieveResponse
}



export const getPokeathlonStatRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/pokeathlon-stat/${id}/`] as const;
    }

    
export const getPokeathlonStatRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof pokeathlonStatRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokeathlonStatRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPokeathlonStatRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pokeathlonStatRetrieve>>> = ({ signal }) => pokeathlonStatRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pokeathlonStatRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PokeathlonStatRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof pokeathlonStatRetrieve>>>
export type PokeathlonStatRetrieveQueryError = unknown


export function usePokeathlonStatRetrieve<TData = Awaited<ReturnType<typeof pokeathlonStatRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokeathlonStatRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokeathlonStatRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokeathlonStatRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokeathlonStatRetrieve<TData = Awaited<ReturnType<typeof pokeathlonStatRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokeathlonStatRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokeathlonStatRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokeathlonStatRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePokeathlonStatRetrieve<TData = Awaited<ReturnType<typeof pokeathlonStatRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokeathlonStatRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get pokeathlon stat
 */

export function usePokeathlonStatRetrieve<TData = Awaited<ReturnType<typeof pokeathlonStatRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pokeathlonStatRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPokeathlonStatRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Stats determine certain aspects of battles. Each Pokémon has a value for each stat which grows as they gain levels and can be altered momentarily by effects in battles.
 * @summary List stats
 */
export type statListResponse200 = {
  data: PaginatedStatSummaryList
  status: 200
}
    
export type statListResponseComposite = statListResponse200;
    
export type statListResponse = statListResponseComposite & {
  headers: Headers;
}

export const getStatListUrl = (params?: StatListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/stat/?${stringifiedParams}` : `https://pokeapi.co/api/v2/stat/`
}

export const statList = async (params?: StatListParams, options?: RequestInit): Promise<statListResponse> => {
  
  const res = await fetch(getStatListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: statListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as statListResponse
}



export const getStatListQueryKey = (params?: StatListParams,) => {
    return [`https://pokeapi.co/api/v2/stat/`, ...(params ? [params]: [])] as const;
    }

    
export const getStatListQueryOptions = <TData = Awaited<ReturnType<typeof statList>>, TError = unknown>(params?: StatListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStatListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof statList>>> = ({ signal }) => statList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof statList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StatListQueryResult = NonNullable<Awaited<ReturnType<typeof statList>>>
export type StatListQueryError = unknown


export function useStatList<TData = Awaited<ReturnType<typeof statList>>, TError = unknown>(
 params: undefined |  StatListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof statList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof statList>>,
          TError,
          Awaited<ReturnType<typeof statList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStatList<TData = Awaited<ReturnType<typeof statList>>, TError = unknown>(
 params?: StatListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof statList>>,
          TError,
          Awaited<ReturnType<typeof statList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStatList<TData = Awaited<ReturnType<typeof statList>>, TError = unknown>(
 params?: StatListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List stats
 */

export function useStatList<TData = Awaited<ReturnType<typeof statList>>, TError = unknown>(
 params?: StatListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStatListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Stats determine certain aspects of battles. Each Pokémon has a value for each stat which grows as they gain levels and can be altered momentarily by effects in battles.
 * @summary Get stat
 */
export type statRetrieveResponse200 = {
  data: StatDetail
  status: 200
}
    
export type statRetrieveResponseComposite = statRetrieveResponse200;
    
export type statRetrieveResponse = statRetrieveResponseComposite & {
  headers: Headers;
}

export const getStatRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/stat/${id}/`
}

export const statRetrieve = async (id: string, options?: RequestInit): Promise<statRetrieveResponse> => {
  
  const res = await fetch(getStatRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: statRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as statRetrieveResponse
}



export const getStatRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/stat/${id}/`] as const;
    }

    
export const getStatRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof statRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStatRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof statRetrieve>>> = ({ signal }) => statRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof statRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StatRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof statRetrieve>>>
export type StatRetrieveQueryError = unknown


export function useStatRetrieve<TData = Awaited<ReturnType<typeof statRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof statRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof statRetrieve>>,
          TError,
          Awaited<ReturnType<typeof statRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStatRetrieve<TData = Awaited<ReturnType<typeof statRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof statRetrieve>>,
          TError,
          Awaited<ReturnType<typeof statRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStatRetrieve<TData = Awaited<ReturnType<typeof statRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get stat
 */

export function useStatRetrieve<TData = Awaited<ReturnType<typeof statRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStatRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Types are properties for Pokémon and their moves. Each type has three properties: which types of Pokémon it is super effective against, which types of Pokémon it is not very effective against, and which types of Pokémon it is completely ineffective against.
 * @summary List types
 */
export type typeListResponse200 = {
  data: PaginatedTypeSummaryList
  status: 200
}
    
export type typeListResponseComposite = typeListResponse200;
    
export type typeListResponse = typeListResponseComposite & {
  headers: Headers;
}

export const getTypeListUrl = (params?: TypeListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://pokeapi.co/api/v2/type/?${stringifiedParams}` : `https://pokeapi.co/api/v2/type/`
}

export const typeList = async (params?: TypeListParams, options?: RequestInit): Promise<typeListResponse> => {
  
  const res = await fetch(getTypeListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: typeListResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as typeListResponse
}



export const getTypeListQueryKey = (params?: TypeListParams,) => {
    return [`https://pokeapi.co/api/v2/type/`, ...(params ? [params]: [])] as const;
    }

    
export const getTypeListQueryOptions = <TData = Awaited<ReturnType<typeof typeList>>, TError = unknown>(params?: TypeListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof typeList>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTypeListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof typeList>>> = ({ signal }) => typeList(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof typeList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TypeListQueryResult = NonNullable<Awaited<ReturnType<typeof typeList>>>
export type TypeListQueryError = unknown


export function useTypeList<TData = Awaited<ReturnType<typeof typeList>>, TError = unknown>(
 params: undefined |  TypeListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof typeList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof typeList>>,
          TError,
          Awaited<ReturnType<typeof typeList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTypeList<TData = Awaited<ReturnType<typeof typeList>>, TError = unknown>(
 params?: TypeListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof typeList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof typeList>>,
          TError,
          Awaited<ReturnType<typeof typeList>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTypeList<TData = Awaited<ReturnType<typeof typeList>>, TError = unknown>(
 params?: TypeListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof typeList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List types
 */

export function useTypeList<TData = Awaited<ReturnType<typeof typeList>>, TError = unknown>(
 params?: TypeListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof typeList>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTypeListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Types are properties for Pokémon and their moves. Each type has three properties: which types of Pokémon it is super effective against, which types of Pokémon it is not very effective against, and which types of Pokémon it is completely ineffective against.
 * @summary Get types
 */
export type typeRetrieveResponse200 = {
  data: TypeDetail
  status: 200
}
    
export type typeRetrieveResponseComposite = typeRetrieveResponse200;
    
export type typeRetrieveResponse = typeRetrieveResponseComposite & {
  headers: Headers;
}

export const getTypeRetrieveUrl = (id: string,) => {


  

  return `https://pokeapi.co/api/v2/type/${id}/`
}

export const typeRetrieve = async (id: string, options?: RequestInit): Promise<typeRetrieveResponse> => {
  
  const res = await fetch(getTypeRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: typeRetrieveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as typeRetrieveResponse
}



export const getTypeRetrieveQueryKey = (id: string,) => {
    return [`https://pokeapi.co/api/v2/type/${id}/`] as const;
    }

    
export const getTypeRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof typeRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof typeRetrieve>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTypeRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof typeRetrieve>>> = ({ signal }) => typeRetrieve(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof typeRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TypeRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof typeRetrieve>>>
export type TypeRetrieveQueryError = unknown


export function useTypeRetrieve<TData = Awaited<ReturnType<typeof typeRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof typeRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof typeRetrieve>>,
          TError,
          Awaited<ReturnType<typeof typeRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTypeRetrieve<TData = Awaited<ReturnType<typeof typeRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof typeRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof typeRetrieve>>,
          TError,
          Awaited<ReturnType<typeof typeRetrieve>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTypeRetrieve<TData = Awaited<ReturnType<typeof typeRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof typeRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get types
 */

export function useTypeRetrieve<TData = Awaited<ReturnType<typeof typeRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof typeRetrieve>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTypeRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



